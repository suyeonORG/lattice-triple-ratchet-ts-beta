/**
 * NOTE: This implementation requires the 'noble-curves' and 'noble-hashes' libraries.
 * Install them using: npm install @noble/curves @noble/hashes
 */
import { p256 } from '@noble/curves/p256'; // P-256 curve operations
import { sha256 } from '@noble/hashes/sha256'; // SHA256 hash function
import { hmac } from '@noble/hashes/hmac'; // HMAC for HKDF
import { bytesToHex, hexToBytes } from '@noble/hashes/utils'; // Hex conversion utilities

/**
 * constants.ts
 *
 * Triple Ratchet - Constants
 */
export const CURVE_NAME = "P-256"; // Still relevant for context, matches noble p256
export const HASH_ALGORITHM_NAME = "SHA-256"; // For Web Crypto hashData
export const HMAC_ALGORITHM = { name: "HMAC", hash: { name: "SHA-256" } } as const; // For Web Crypto HKDF/HMACKey import
export const AES_ALGORITHM = { name: "AES-GCM", length: 256 } as const; // For Web Crypto AES
export const INFO_RATCHET = new TextEncoder().encode("TripleRatchetInfo");
export const MAX_SKIP = 100; // Maximum number of message keys to skip
const P256_ORDER = p256.CURVE.n; // Order of the P-256 curve for modular arithmetic

// --- types/index.ts ---

/**
 * types/index.ts
 *
 * Triple Ratchet - Core type definitions (Functional Style with Noble-Curves)
 */

// Cryptographic key types using noble-curves format (Uint8Array) and Web Crypto
export type ECDHPublicKey = Uint8Array; // Uncompressed or Compressed Point Bytes
export type ECDHPrivateKey = Uint8Array; // 32-byte scalar
export type ECDSAPublicKey = Uint8Array; // Uncompressed or Compressed Point Bytes
export type ECDSAPrivateKey = Uint8Array; // 32-byte scalar
export type HMACKey = CryptoKey; // Web Crypto API Key Object
export type AESKey = CryptoKey; // Web Crypto API Key Object

// Key pair types
export interface ECKeyPair {
  publicKey: ECDHPublicKey;
  privateKey: ECDHPrivateKey;
}

export interface SigningKeyPair {
  publicKey: ECDSAPublicKey;
  privateKey: ECDSAPrivateKey;
}

// Serialized EC public key format (Using Hex for simplicity)
export type SerializedECPublicKey = string; // Hex representation of public key bytes

// Message types for the Triple Ratchet protocol
export enum MessageType {
  NORMAL = 0,
  PRE_KEY = 1,
}

// A message header contains metadata for a ratchet message
export interface MessageHeader {
  publicKey: ECDHPublicKey; // Sender's ratchet public key (bytes)
  previousCounter: number; // Number of messages in previous sending chain
  messageCounter: number; // Message number in current chain
}

// A ratchet message contains the encrypted data and metadata
export interface RatchetMessage {
  type: MessageType;
  header: MessageHeader;
  ciphertext: ArrayBuffer;
  // For PreKeyMessages only
  identityKey?: ECDHPublicKey; // Sender's long-term identity key (bytes)
  preKeyId?: number;
  signedPreKeyId?: number;
}

// The message keys used for encryption/decryption
export interface MessageKeys {
  encKey: AESKey; // Web Crypto AES Key
  authKey: HMACKey; // Web Crypto HMAC Key
  iv: ArrayBuffer;
}

// A PreKeyBundle is used to establish initial communication
export interface PreKeyBundle {
  identityId: number;
  identityKey: ECDHPublicKey; // bytes
  signedPreKeyId: number;
  signedPreKey: ECDHPublicKey; // bytes
  signedPreKeySignature: Uint8Array; // Signature bytes
  preKeyId: number;
  preKey: ECDHPublicKey; // bytes
  signingKey: ECDSAPublicKey; // Public signing key of the bundle owner (bytes)
}

// --- State Types for Functional Approach ---

/**
 * State for a symmetric key ratchet chain (sending or receiving)
 */
export interface RatchetChainState {
  chainKey: HMACKey; // Web Crypto Key
  chainIndex: number;
  skippedMessageKeys: Map<number, MessageKeys>; // Stores keys for out-of-order messages
}

/**
 * Represents the complete state of a Triple Ratchet session for one party
 */
export interface RatchetState {
  // Own identity info (simplified for this example)
  identityPrivateKey: ECDHPrivateKey; // bytes
  identityPublicKey: ECDHPublicKey; // bytes

  // Remote party's identity info
  remoteIdentityKey: ECDHPublicKey; // bytes
  remoteSigningKey: ECDSAPublicKey; // bytes

  // Core Ratchet State
  rootKey: HMACKey; // Web Crypto Key
  ourRatchetKeyPair: ECKeyPair; // Our current ephemeral DH key pair (bytes)
  theirRatchetKey: ECDHPublicKey | null; // Their current ephemeral DH public key (bytes)

  // Triple Ratchet Enhancement
  // This now holds the actual enhanced private key scalar bytes x_t' = x_t * H(I_t) mod q
  ourEnhancedPrivateKey: ECDHPrivateKey; // bytes

  // Symmetric Key Ratchet Chains
  sendingChain: RatchetChainState | null;
  receivingChain: RatchetChainState | null;

  // Counters
  sendMsgCounter: number; // Messages sent in the current sending chain
  recvMsgCounter: number; // Messages received in the current receiving chain (Note: might not be needed if using chainIndex)
  prevSendMsgCounter: number; // Number of messages sent in the *previous* sending chain

  // Storage for message keys skipped during DH ratchet steps
  // Key: Hex(remote public key) + message counter
  skippedRatchetKeys: Map<string, MessageKeys>;
}

/**
 * Represents the state of a user's identity keys (simplified)
 */
export interface IdentityState {
    id: number;
    signingKeyPair: SigningKeyPair; // bytes
    dhKeyPair: ECKeyPair; // bytes
    // Add maps for preKeys (ECKeyPair), signedPreKeys (ECKeyPair), signatures (Map<number, Uint8Array>) etc.
    preKeys: Map<number, ECKeyPair>;
    signedPreKeys: Map<number, ECKeyPair>;
    signedPreKeySignatures: Map<number, Uint8Array>;
}


// --- utils/environment.ts ---

/**
 * utils/environment.ts
 * Environment detection utilities
 */
export const isBrowser =
  typeof window !== "undefined" && typeof window.crypto !== "undefined";

/**
 * Gets the crypto implementation from the environment (for Web Crypto parts).
 * @throws Error if Web Crypto API is not available.
 * @returns The Crypto object.
 */
export function getCrypto(): Crypto {
  if (isBrowser) {
    return window.crypto;
  }
  throw new Error("Web Crypto API is not available in this environment");
}


// --- utils/buffer.ts ---

/**
 * utils/buffer.ts
 * Buffer utilities for the Triple Ratchet
 */

/**
 * Concatenates multiple ArrayBuffers or Uint8Arrays.
 * @param buffers ArrayBuffers or Uint8Arrays to concatenate.
 * @returns A new Uint8Array containing the concatenated data.
 */
export function concatBuffers(...buffers: (ArrayBuffer | Uint8Array)[]): Uint8Array {
  const totalLength = buffers.reduce((sum, buf) => sum + buf.byteLength, 0);
  const result = new Uint8Array(totalLength);
  let offset = 0;

  for (const buffer of buffers) {
    result.set(new Uint8Array(buffer), offset);
    offset += buffer.byteLength;
  }

  return result;
}

/**
 * Compares two ArrayBuffers or Uint8Arrays for equality.
 * Uses constant time comparison if possible.
 * @param a The first buffer.
 * @param b The second buffer.
 * @returns True if the buffers are identical, false otherwise.
 */
export function equalBuffers(a: ArrayBuffer | Uint8Array, b: ArrayBuffer | Uint8Array): boolean {
    const viewA = new Uint8Array(a);
    const viewB = new Uint8Array(b);

    if (viewA.length !== viewB.length) {
        return false;
    }

    // Constant time comparison
    let diff = 0;
    for (let i = 0; i < viewA.length; i++) {
        diff |= viewA[i] ^ viewB[i];
    }
    return diff === 0;
}

// Use noble-hashes utilities for hex conversion
export { bytesToHex, hexToBytes };

/**
 * Converts a UTF-8 string to an Uint8Array.
 * @param str The string to encode.
 * @returns The Uint8Array representation.
 */
export function stringToBytes(str: string): Uint8Array {
    return new TextEncoder().encode(str);
}

/**
 * Converts an ArrayBuffer or Uint8Array to a UTF-8 string.
 * @param buffer The buffer to decode.
 * @returns The decoded string.
 */
export function bytesToString(buffer: ArrayBuffer | Uint8Array): string {
    return new TextDecoder().decode(buffer);
}


// --- crypto/crypto-utils.ts ---

/**
 * crypto/crypto-utils.ts
 * Crypto utilities combining noble-curves for EC ops and Web Crypto for others.
 */

/**
 * Generates a new ECDH key pair (P-256) using noble-curves.
 * @returns An ECKeyPair with keys as Uint8Array.
 */
export function generateECDHKeyPair(): ECKeyPair {
  const privateKey = p256.utils.randomPrivateKey();
  const publicKey = p256.getPublicKey(privateKey, false); // false = uncompressed format
  return {
    privateKey: privateKey, // 32 bytes scalar
    publicKey: publicKey,   // 65 bytes (0x04 + x + y)
  };
}

/**
 * Generates a new ECDSA signing key pair (P-256) using noble-curves.
 * @returns A SigningKeyPair with keys as Uint8Array.
 */
export function generateSigningKeyPair(): SigningKeyPair {
  const privateKey = p256.utils.randomPrivateKey();
  const publicKey = p256.getPublicKey(privateKey, false); // Use uncompressed for consistency
  return {
    privateKey: privateKey,
    publicKey: publicKey,
  };
}

/**
 * Computes Diffie-Hellman shared secret using noble-curves (P-256).
 * @param privateKey Our ECDH private key bytes.
 * @param publicKey Their ECDH public key bytes (uncompressed or compressed).
 * @returns The shared secret as a Uint8Array (32 bytes, x-coordinate).
 */
export function computeDH(
  privateKey: ECDHPrivateKey,
  publicKey: ECDHPublicKey
): Uint8Array {
    // noble automatically handles compressed/uncompressed public keys
    const sharedPoint = p256.getSharedSecret(privateKey, publicKey);
    // The shared secret is the x-coordinate of the shared point.
    // Need to hash it? Signal spec often uses KDF on the raw point.
    // Let's return the 32-byte x-coordinate as is common.
    return sharedPoint.slice(0, 32);
}


/**
 * Derives keys using HKDF (HMAC-SHA256) via Web Crypto.
 * @param input The input key material (IKM) (ArrayBuffer or Uint8Array).
 * @param salt Optional salt (recommended) (ArrayBuffer or Uint8Array). Defaults to zero bytes.
 * @param info Optional context/application-specific info (ArrayBuffer or Uint8Array). Defaults to empty.
 * @param keyCount The number of output keys to derive.
 * @param keyLengthBytes The length of each derived key in bytes (default: 32).
 * @returns A Promise resolving to an array of derived keys (ArrayBuffer).
 */
export async function hkdfDerive(
  input: ArrayBuffer | Uint8Array,
  salt: ArrayBuffer | Uint8Array | null,
  info: ArrayBuffer | Uint8Array | null,
  keyCount: number,
  keyLengthBytes: number = 32
): Promise<ArrayBuffer[]> {
  const crypto = getCrypto();
  const saltBytes = salt ? new Uint8Array(salt) : new Uint8Array(32); // Default salt: 32 zeros
  const infoBytes = info ? new Uint8Array(info) : new Uint8Array(0); // Default info: empty
  const inputBytes = new Uint8Array(input);

  // 1. Import IKM as a temporary key for HKDF (this usage is standard)
  const ikmKey = await crypto.subtle.importKey(
      "raw",
      inputBytes,
      { name: "HKDF" }, // Algorithm for import
      false, // not extractable
      ["deriveKey"] // Usage
  );

  // 2. Derive the keys
  const derivedKeyPromises = [];
  for (let i = 0; i < keyCount; i++) {
      // Info for each key can be made unique if needed, e.g., by appending index
      const currentInfo = concatBuffers(infoBytes, new Uint8Array([i])); // Example: Append index to info

      derivedKeyPromises.push(
          crypto.subtle.deriveKey(
              {
                  name: "HKDF",
                  salt: saltBytes,
                  info: currentInfo,
                  hash: HASH_ALGORITHM_NAME,
              },
              ikmKey, // Base key
              { name: "HMAC", hash: HASH_ALGORITHM_NAME, length: keyLengthBytes * 8 }, // Derived key algorithm + length
              true, // Allow export (needed to get raw bytes)
              ["sign", "verify"] // Example usages for HMAC keys
          ).then(key => crypto.subtle.exportKey("raw", key)) // Export to get ArrayBuffer
      );
  }

  return Promise.all(derivedKeyPromises);

  /* // Manual HKDF using noble-hashes (alternative if Web Crypto HKDF is problematic)
    const prk = hmac(sha256, salt || new Uint8Array(32), input); // Extract
    const T = [new Uint8Array(0)]; // T(0)
    const okm = new Uint8Array(keyCount * keyLengthBytes);
    const numBlocks = Math.ceil((keyCount * keyLengthBytes) / 32); // 32 = sha256 output len

    if (numBlocks > 255) throw new Error("Too many keys requested from HKDF");

    for (let i = 1; i <= numBlocks; i++) {
        const inputT = concatBuffers(T[i-1], info || new Uint8Array(0), new Uint8Array([i]));
        T[i] = hmac(sha256, prk, inputT); // Expand
        okm.set(T[i], (i-1) * 32);
    }
    const result: ArrayBuffer[] = [];
    for(let i = 0; i < keyCount; i++) {
        result.push(okm.slice(i * keyLengthBytes, (i + 1) * keyLengthBytes).buffer);
    }
    return Promise.resolve(result); // Wrap in promise to match Web Crypto async
  */
}


/**
 * Imports a raw key as an HMAC key (SHA-256) using Web Crypto.
 * @param keyData The raw key material (ArrayBuffer or Uint8Array).
 * @returns A Promise resolving to the HMACKey (CryptoKey).
 */
export async function importHmacKey(keyData: ArrayBuffer | Uint8Array): Promise<HMACKey> {
  const crypto = getCrypto();
  return crypto.subtle.importKey(
      "raw",
      keyData,
      HMAC_ALGORITHM,
      false, // not extractable
      ["sign", "verify"]
  );
}

/**
 * Imports a raw key as an AES-GCM key (256-bit) using Web Crypto.
 * @param keyData The raw key material (ArrayBuffer or Uint8Array, must be 32 bytes).
 * @returns A Promise resolving to the AESKey (CryptoKey).
 * @throws Error if keyData is not 32 bytes.
 */
export async function importAesKey(keyData: ArrayBuffer | Uint8Array): Promise<AESKey> {
  const keyBytes = new Uint8Array(keyData);
  if (keyBytes.length !== 32) {
      throw new Error(`AES key data must be 32 bytes, received ${keyBytes.length}`);
  }
  const crypto = getCrypto();
  return crypto.subtle.importKey(
      "raw",
      keyBytes,
      AES_ALGORITHM,
      false, // not extractable
      ["encrypt", "decrypt"]
  );
}

/**
 * Signs data with an ECDSA private key (P-256 SHA-256) using noble-curves.
 * @param privateKey The ECDSAPrivateKey bytes to sign with.
 * @param data The Uint8Array data to sign (message hash recommended).
 * @returns A Promise resolving to the signature as a Uint8Array (DER format or raw R/S). Noble returns raw R/S format.
 */
export async function signData(
  privateKey: ECDSAPrivateKey,
  data: Uint8Array // Should typically be the SHA256 hash of the message
): Promise<Uint8Array> {
    // Note: noble's sign expects the *hash* of the message, not the raw message.
    // Hash the data first if it's not already a hash.
    const messageHash = sha256(data);
    const signature = await p256.ecdsaSign(messageHash, privateKey);
    // The signature object contains r and s bigints. Convert to standard format.
    // Compact format (r || s) is common. 64 bytes for P-256.
    return signature.toCompactRawBytes();
}

/**
 * Verifies an ECDSA signature (P-256 SHA-256) using noble-curves.
 * @param publicKey The ECDSAPublicKey bytes to verify with.
 * @param signature The signature Uint8Array (compact R/S format expected).
 * @param data The original data Uint8Array (will be hashed internally).
 * @returns A Promise resolving to true if the signature is valid, false otherwise.
 */
export async function verifySignature(
  publicKey: ECDSAPublicKey,
  signature: Uint8Array, // Expecting compact R/S format
  data: Uint8Array // The original data that was signed (will be hashed)
): Promise<boolean> {
    // Hash the data first
    const messageHash = sha256(data);
    try {
        return p256.ecdsaVerify(signature, messageHash, publicKey);
    } catch (error) {
        console.error("Signature verification failed:", error);
        return false; // Treat errors during verification as invalid signature
    }
}

/**
 * Serializes an EC public key (Uint8Array) to a hex string.
 * @param publicKey The public key bytes.
 * @returns The hex string representation.
 */
export function serializePublicKey(publicKey: ECDHPublicKey | ECDSAPublicKey): SerializedECPublicKey {
    return bytesToHex(publicKey);
}

/**
 * Deserializes an EC public key from a hex string.
 * @param serialized The hex string representation.
 * @returns The public key as Uint8Array.
 */
export function deserializePublicKey(serialized: SerializedECPublicKey): Uint8Array {
    return hexToBytes(serialized);
}

/**
 * Computes a SHA-256 hash of the input data using Web Crypto.
 * @param data The ArrayBuffer or Uint8Array data to hash.
 * @returns A Promise resolving to the hash digest as an ArrayBuffer (32 bytes).
 */
export async function hashData(data: ArrayBuffer | Uint8Array): Promise<ArrayBuffer> {
  const crypto = getCrypto();
  return crypto.subtle.digest(HASH_ALGORITHM_NAME, data);
}

/**
 * Encrypts data using AES-GCM (256-bit) via Web Crypto.
 * @param key The AESKey (CryptoKey) to use for encryption.
 * @param plaintext The ArrayBuffer or Uint8Array data to encrypt.
 * @param iv The initialization vector (ArrayBuffer or Uint8Array, typically 12 bytes).
 * @param additionalData Optional additional authenticated data (AAD) (ArrayBuffer or Uint8Array).
 * @returns A Promise resolving to the ciphertext as an ArrayBuffer.
 */
export async function encryptAES(
  key: AESKey,
  plaintext: ArrayBuffer | Uint8Array,
  iv: ArrayBuffer | Uint8Array,
  additionalData?: ArrayBuffer | Uint8Array
): Promise<ArrayBuffer> {
  const crypto = getCrypto();
  const params: AesGcmParams = {
      name: AES_ALGORITHM.name,
      iv: iv,
  };
  if (additionalData) {
      params.additionalData = additionalData;
  }
  return crypto.subtle.encrypt(params, key, plaintext);
}

/**
 * Decrypts data using AES-GCM (256-bit) via Web Crypto.
 * @param key The AESKey (CryptoKey) to use for decryption.
 * @param ciphertext The ArrayBuffer or Uint8Array data to decrypt.
 * @param iv The initialization vector (ArrayBuffer or Uint8Array) used during encryption.
 * @param additionalData Optional additional authenticated data (AAD) used during encryption.
 * @returns A Promise resolving to the original plaintext as an ArrayBuffer.
 * @throws Error if decryption fails.
 */
export async function decryptAES(
  key: AESKey,
  ciphertext: ArrayBuffer | Uint8Array,
  iv: ArrayBuffer | Uint8Array,
  additionalData?: ArrayBuffer | Uint8Array
): Promise<ArrayBuffer> {
  const crypto = getCrypto();
   const params: AesGcmParams = {
      name: AES_ALGORITHM.name,
      iv: iv,
  };
  if (additionalData) {
      params.additionalData = additionalData;
  }
  try {
      return await crypto.subtle.decrypt(params, key, ciphertext);
  } catch (e) {
      console.error("AES decryption failed:", e);
      throw new Error(`Decryption failed. Data may be corrupt or key/IV incorrect. ${e}`);
  }
}

/**
 * Exports a Web Crypto CryptoKey to its raw representation (ArrayBuffer).
 * @param key The CryptoKey to export (must be exportable and support 'raw' format).
 * @returns A Promise resolving to the raw key material as an ArrayBuffer.
 */
export async function exportRawKey(key: CryptoKey): Promise<ArrayBuffer> {
    const crypto = getCrypto();
    try {
        return await crypto.subtle.exportKey("raw", key);
    } catch (e) {
        console.error("Failed to export raw key:", e);
        throw new Error(`Could not export key in raw format: ${e}`);
    }
}

/**
 * Compares two public keys (Uint8Array) for equality.
 * @param keyA The first public key bytes.
 * @param keyB The second public key bytes.
 * @returns True if the keys are equal, false otherwise.
 */
export function equalPublicKeys(keyA: ECDHPublicKey | ECDSAPublicKey, keyB: ECDHPublicKey | ECDSAPublicKey): boolean {
    return equalBuffers(keyA, keyB);
}


// --- protocol/ratchet-logic.ts ---

/**
 * protocol/ratchet-logic.ts
 *
 * Core functional logic for the Triple Ratchet protocol state transitions.
 */

// --- Symmetric Key Ratchet (Chain Key) Logic ---

/**
 * Derives message keys (AES encryption key, HMAC auth key, IV) from a chain key state.
 * Uses Web Crypto keys. Does not advance the chain state itself.
 * @param chainKey The current HMAC chain key (CryptoKey).
 * @returns A Promise resolving to the MessageKeys.
 */
async function deriveMessageKeysFromChainKey(chainKey: HMACKey): Promise<MessageKeys> {
    const crypto = getCrypto();
    const messageKeyInput = stringToBytes("MessageKey");

    // Derive a combined key using HMAC sign operation
    const derivedCombinedKey = await crypto.subtle.sign(HMAC_ALGORITHM.name, chainKey, messageKeyInput);

    // Use HKDF to split the derived key into AES key, Auth key, and IV
    const keys = await hkdfDerive(derivedCombinedKey, null, INFO_RATCHET, 3, 32);

    const iv = keys[2].slice(0, 12); // Use 12 bytes for AES-GCM IV

    return {
        encKey: await importAesKey(keys[0]),
        authKey: await importHmacKey(keys[1]), // Import auth key for potential MAC use later
        iv: iv,
    };
}

/**
 * Advances a chain key state to the next key in the sequence.
 * Uses Web Crypto keys.
 * @param chainKey The current HMAC chain key (CryptoKey).
 * @returns A Promise resolving to the next HMAC chain key (CryptoKey).
 */
async function advanceChainKey(chainKey: HMACKey): Promise<HMACKey> {
    const crypto = getCrypto();
    const nextKeyInput = stringToBytes("NextChainKey");
    const nextKeyMaterial = await crypto.subtle.sign(HMAC_ALGORITHM.name, chainKey, nextKeyInput);
    return importHmacKey(nextKeyMaterial);
}

/**
 * Gets a message key from a symmetric ratchet chain state for a specific counter.
 * Advances the chain state past the requested counter and stores skipped keys.
 * @param chainState The current state of the symmetric ratchet chain.
 * @param counter The desired message counter index.
 * @returns A Promise resolving to an object containing the MessageKeys and the updated RatchetChainState.
 * @throws Error if the requested counter is too far in the past or skipped keys exceed MAX_SKIP.
 */
export async function getSymRatchetMessageKey(
    chainState: RatchetChainState,
    counter: number
): Promise<{ messageKeys: MessageKeys; nextChainState: RatchetChainState }> {
    let currentChainKey = chainState.chainKey;
    let currentIndex = chainState.chainIndex;
    const newSkippedKeys = new Map(chainState.skippedMessageKeys); // Clone skipped keys

    // Check if the key is already skipped
    if (newSkippedKeys.has(counter)) {
        const messageKeys = newSkippedKeys.get(counter)!;
        newSkippedKeys.delete(counter);
        return {
            messageKeys,
            nextChainState: { ...chainState, skippedMessageKeys: newSkippedKeys },
        };
    }

    if (counter < currentIndex) {
        throw new Error(`Message key for past counter ${counter} not found (current index: ${currentIndex})`);
    }
    if (counter - currentIndex > MAX_SKIP) {
        throw new Error(`Skipping too many messages (${counter - currentIndex}, max: ${MAX_SKIP})`);
    }

    // Advance the chain until the desired counter is reached
    while (currentIndex < counter) {
        const messageKeys = await deriveMessageKeysFromChainKey(currentChainKey);
        newSkippedKeys.set(currentIndex, messageKeys);
        currentChainKey = await advanceChainKey(currentChainKey);
        currentIndex++;

        // Optional: Prune very old skipped keys
        if (newSkippedKeys.size > MAX_SKIP * 2) {
             const oldestKey = Math.min(...newSkippedKeys.keys());
             if (currentIndex - oldestKey > MAX_SKIP * 2) {
                 newSkippedKeys.delete(oldestKey);
             }
        }
    }

    const requestedMessageKeys = await deriveMessageKeysFromChainKey(currentChainKey);
    const nextChainKey = await advanceChainKey(currentChainKey);
    const nextIndex = currentIndex + 1;

    const nextState: RatchetChainState = {
        chainKey: nextChainKey,
        chainIndex: nextIndex,
        skippedMessageKeys: newSkippedKeys,
    };

    return { messageKeys: requestedMessageKeys, nextChainState: nextState };
}


// --- Diffie-Hellman (DH) Ratchet Logic ---

/**
 * Performs the DH ratchet step calculation using Web Crypto HKDF.
 * Derives a new root key and a new chain key from the DH result and the current root key.
 * @param rootKey The current root key (HMACKey - CryptoKey).
 * @param dhOutput The result of the ECDH computation (Uint8Array).
 * @returns A Promise resolving to { newRootKey: HMACKey, newChainKey: HMACKey }.
 */
async function performDHRatchetStep(
    rootKey: HMACKey,
    dhOutput: Uint8Array
): Promise<{ newRootKey: HMACKey; newChainKey: HMACKey }> {
    const rootKeyRaw = await exportRawKey(rootKey); // Export key to use as HKDF salt

    // Derive 2 new keys: the next root key and the next chain key
    const derivedKeys = await hkdfDerive(dhOutput, rootKeyRaw, INFO_RATCHET, 2);

    const newRootKey = await importHmacKey(derivedKeys[0]);
    const newChainKey = await importHmacKey(derivedKeys[1]);

    return { newRootKey, newChainKey };
}


// --- Triple Ratchet Enhancement ---

/**
 * Converts a Uint8Array to a BigInt. Assumes big-endian format.
 * @param bytes The input bytes.
 * @returns The corresponding BigInt.
 */
function bytesToBigInt(bytes: Uint8Array): bigint {
    let result = 0n;
    for (let i = 0; i < bytes.length; i++) {
        result = (result << 8n) + BigInt(bytes[i]);
    }
    return result;
}

/**
 * Calculates the "enhanced" private key for the Triple Ratchet: x_t' = (x_t * H(I_t)) mod n
 * Uses noble-curves for modular arithmetic.
 * @param privateKeyBytes The original private key scalar bytes (x_t).
 * @param sharedSecret The shared secret derived via DH (I_t) (Uint8Array).
 * @returns A Promise resolving to the enhanced private key bytes (x_t').
 */
async function calculateEnhancedPrivateKey(
    privateKeyBytes: ECDHPrivateKey,
    sharedSecret: Uint8Array // I_t
): Promise<ECDHPrivateKey> {
    // 1. Hash the shared secret: H(I_t)
    // Use noble-hashes sha256 which returns Uint8Array directly
    const hashedSecretBytes = sha256(sharedSecret); // H(I_t)

    // 2. Convert private key and hash to BigInt scalars
    const privateScalar = bytesToBigInt(privateKeyBytes); // x_t
    const hashScalar = bytesToBigInt(hashedSecretBytes); // H(I_t) as scalar

    // 3. Perform modular multiplication: (x_t * H(I_t)) mod n
    // P256_ORDER (n) is the order of the curve
    const enhancedScalar = p256.utils.mod(privateScalar * hashScalar, P256_ORDER);

    // 4. Convert the resulting BigInt scalar back to 32 bytes (Uint8Array)
    // Use noble-curves utility for this conversion.
    const enhancedPrivateKeyBytes = p256.utils.scalarToBytes(enhancedScalar);

    console.debug("Triple Ratchet: Enhanced private key calculated.");
    return enhancedPrivateKeyBytes;
}


// --- Ratchet Initialization Logic ---

/**
 * Initializes the RatchetState for the initiator using the recipient's PreKeyBundle.
 * Uses noble-curves for EC operations.
 * @param ownIdentityState Our identity information.
 * @param preKeyBundle The recipient's PreKeyBundle.
 * @returns A Promise resolving to the initial RatchetState for the initiator.
 * @throws Error if the PreKeyBundle signature is invalid.
 */
export async function initializeRatchetInitiator(
    ownIdentityState: IdentityState,
    preKeyBundle: PreKeyBundle
): Promise<RatchetState> {
    // 1. Verify the signed prekey signature
    // The data signed is typically the public key bytes
    const isSignatureValid = await verifySignature(
        preKeyBundle.signingKey, // Their public signing key
        preKeyBundle.signedPreKeySignature, // The signature
        preKeyBundle.signedPreKey // The public key bytes that were signed
    );

    if (!isSignatureValid) {
        throw new Error("Invalid signature on signed prekey in PreKeyBundle.");
    }

    // 2. Generate our ephemeral key pair for this session
    const ephemeralKeyPair = generateECDHKeyPair();

    // 3. Perform X3DH calculations
    const dh1 = computeDH(ownIdentityState.dhKeyPair.privateKey, preKeyBundle.signedPreKey);
    const dh2 = computeDH(ephemeralKeyPair.privateKey, preKeyBundle.identityKey);
    const dh3 = computeDH(ephemeralKeyPair.privateKey, preKeyBundle.signedPreKey);
    const dh4 = computeDH(ephemeralKeyPair.privateKey, preKeyBundle.preKey);

    // 4. Combine DH outputs -> Shared Secret (SK)
    const sharedSecretInput = concatBuffers(dh1, dh2, dh3, dh4); // Simple concatenation

    // 5. Derive initial Root Key from SK using HKDF
    const initialKeys = await hkdfDerive(sharedSecretInput, null, INFO_RATCHET, 1);
    const initialRootKey = await importHmacKey(initialKeys[0]);

    // 6. Generate our first ratchet key pair
    const initialRatchetKeyPair = generateECDHKeyPair();

    // 7. Calculate initial "enhanced" private key
    // No prior shared secret, so it starts as the normal private key.
    // We don't call calculateEnhancedPrivateKey here.
    const initialEnhancedPrivateKey = initialRatchetKeyPair.privateKey;

    // 8. Initial State Setup
    const initialState: RatchetState = {
        identityPrivateKey: ownIdentityState.dhKeyPair.privateKey,
        identityPublicKey: ownIdentityState.dhKeyPair.publicKey,
        remoteIdentityKey: preKeyBundle.identityKey,
        remoteSigningKey: preKeyBundle.signingKey,
        rootKey: initialRootKey,
        ourRatchetKeyPair: initialRatchetKeyPair,
        // Initiator assumes the one-time prekey is the first remote ratchet key.
        // This might be incorrect depending on the exact X3DH flow / message format.
        // Let's assume the first message *from them* will establish their key.
        // For now, set to their signed prekey as a placeholder? Or null?
        // Setting to null seems safer - first received message dictates it.
        theirRatchetKey: null, // Set by first received message
        ourEnhancedPrivateKey: initialEnhancedPrivateKey,
        sendingChain: null, // Created on first encrypt
        receivingChain: null,
        sendMsgCounter: 0,
        recvMsgCounter: 0,
        prevSendMsgCounter: 0,
        skippedRatchetKeys: new Map(),
    };

    return initialState;
}


/**
 * Initializes the RatchetState for the receiver using the first PreKey message.
 * Uses noble-curves for EC operations.
 * @param ownIdentityState Our identity information (needs pre-keys).
 * @param preKeyMessage The received PreKey message.
 * @param ownPreKeyId The ID of our one-time pre-key used by the initiator.
 * @param ownSignedPreKeyId The ID of our signed pre-key used by the initiator.
 * @returns A Promise resolving to the initial RatchetState for the receiver.
 */
export async function initializeRatchetReceiver(
    ownIdentityState: IdentityState, // Needs access to own prekeys
    preKeyMessage: RatchetMessage,
    // PreKey IDs are included in the message in standard Signal X3DH
    // ownPreKeyId: number,
    // ownSignedPreKeyId: number
): Promise<RatchetState> {
    // 1. Validate PreKey message structure
    if (
        preKeyMessage.type !== MessageType.PRE_KEY ||
        !preKeyMessage.identityKey || // Initiator's identity key
        !preKeyMessage.header.publicKey || // Initiator's ephemeral key
        preKeyMessage.preKeyId === undefined ||
        preKeyMessage.signedPreKeyId === undefined
    ) {
        throw new Error("Invalid PreKey message structure for initialization.");
    }

    // 2. Retrieve our necessary private keys from IdentityState
    const ownSignedPreKeyPair = await getSignedPreKeyPair(ownIdentityState, preKeyMessage.signedPreKeyId);
    const ownPreKeyPair = await getOneTimePreKeyPair(ownIdentityState, preKeyMessage.preKeyId);
    if (!ownSignedPreKeyPair || !ownPreKeyPair) {
        throw new Error(`Required pre-key (ID ${preKeyMessage.preKeyId}) or signed pre-key (ID ${preKeyMessage.signedPreKeyId}) not found.`);
    }

    // 3. Perform X3DH calculations
    const dh1 = computeDH(ownSignedPreKeyPair.privateKey, preKeyMessage.identityKey);
    const dh2 = computeDH(ownIdentityState.dhKeyPair.privateKey, preKeyMessage.header.publicKey);
    const dh3 = computeDH(ownSignedPreKeyPair.privateKey, preKeyMessage.header.publicKey);
    const dh4 = computeDH(ownPreKeyPair.privateKey, preKeyMessage.header.publicKey);

    // 4. Combine DH outputs -> Shared Secret (SK)
    const sharedSecretInput = concatBuffers(dh1, dh2, dh3, dh4);

    // 5. Derive initial Root Key
    const initialKeys = await hkdfDerive(sharedSecretInput, null, INFO_RATCHET, 1);
    const initialRootKey = await importHmacKey(initialKeys[0]);

    // 6. Initiator's ephemeral key is our first "theirRatchetKey"
    const initialTheirRatchetKey = preKeyMessage.header.publicKey;

    // 7. Generate our first ratchet key pair (for the first reply)
    const initialRatchetKeyPair = generateECDHKeyPair();

    // 8. Calculate initial "enhanced" private key
    const initialEnhancedPrivateKey = initialRatchetKeyPair.privateKey;

    // 9. Initial State Setup
    // Need initiator's public signing key to store in remoteSigningKey.
    // X3DH doesn't mandate sending it in the PreKey message.
    // Often fetched from server along with bundle, or identity key IS the signing key.
    // Assume identity key can be used for verification for now (Needs clarification based on protocol).
    const remoteSigningKey = preKeyMessage.identityKey; // Placeholder assumption

    const initialState: RatchetState = {
        identityPrivateKey: ownIdentityState.dhKeyPair.privateKey,
        identityPublicKey: ownIdentityState.dhKeyPair.publicKey,
        remoteIdentityKey: preKeyMessage.identityKey,
        remoteSigningKey: remoteSigningKey, // Store initiator's assumed signing key
        rootKey: initialRootKey,
        ourRatchetKeyPair: initialRatchetKeyPair,
        theirRatchetKey: initialTheirRatchetKey,
        ourEnhancedPrivateKey: initialEnhancedPrivateKey,
        sendingChain: null, // Receiver starts by receiving
        receivingChain: null, // Created by first decrypt
        sendMsgCounter: 0,
        recvMsgCounter: 0,
        prevSendMsgCounter: 0,
        skippedRatchetKeys: new Map(),
    };

    // 10. Receiver must process the initial message using this state.
    return initialState;
}

// --- Encryption Logic ---

/**
 * Encrypts a plaintext message using the current RatchetState.
 * Handles DH ratchet updates and Triple Ratchet enhancement.
 * @param currentState The current RatchetState.
 * @param plaintext The plaintext ArrayBuffer to encrypt.
 * @returns A Promise resolving to { message: RatchetMessage, nextState: RatchetState }.
 */
export async function ratchetEncrypt(
    currentState: RatchetState,
    plaintext: ArrayBuffer
): Promise<{ message: RatchetMessage; nextState: RatchetState }> {
    let nextState = { ...currentState }; // Shallow copy
    let sendingChain = nextState.sendingChain;
    let currentRatchetKeyPair = nextState.ourRatchetKeyPair; // Key pair used for this encryption

    // --- DH Ratchet Step (if needed) ---
    if (!sendingChain) {
        if (!nextState.theirRatchetKey) {
            throw new Error("Cannot encrypt: Remote ratchet key not established.");
        }

        // DH calculation using the *current* enhanced private key
        const dhOutput = computeDH(nextState.ourEnhancedPrivateKey, nextState.theirRatchetKey);
        const { newRootKey, newChainKey } = await performDHRatchetStep(nextState.rootKey, dhOutput);

        sendingChain = { chainKey: newChainKey, chainIndex: 0, skippedMessageKeys: new Map() };

        // Update state: new root key, new sending chain, reset counter
        nextState.rootKey = newRootKey;
        nextState.sendingChain = sendingChain;
        nextState.sendMsgCounter = 0;

        // --- Triple Ratchet Enhancement (Sender Side) ---
        // Generate the *next* key pair we will use for sending.
        const nextRatchetKeyPair = generateECDHKeyPair();
        // Calculate the enhanced version of *our current* private key using the DH output *just computed*.
        // This enhanced key is stored for the *next* DH calculation (if we receive before sending again).
        const nextEnhancedPrivateKey = await calculateEnhancedPrivateKey(
             currentRatchetKeyPair.privateKey, // Use the private key corresponding to the public key just sent/used
             dhOutput
        );

        // Update state with the *new* key pair and *new* enhanced key for the future.
        // The public key used in the *current* message header remains the one from before this update.
        nextState.ourRatchetKeyPair = nextRatchetKeyPair; // Store the next key pair
        nextState.ourEnhancedPrivateKey = nextEnhancedPrivateKey; // Store the calculated enhanced key

    } // End DH Ratchet Step

    // --- Symmetric Ratchet Step ---
    if (!sendingChain) throw new Error("Internal error: Sending chain not available.");

    const currentSendCounter = nextState.sendMsgCounter;
    const { messageKeys, nextChainState: updatedSendingChain } = await getSymRatchetMessageKey(
        sendingChain,
        currentSendCounter
    );

    nextState.sendingChain = updatedSendingChain;
    nextState.sendMsgCounter = currentSendCounter + 1;

    // --- AES Encryption ---
    // Header uses the public key that corresponds to the private key used for the DH step (if any)
    // which is the key from *before* the potential update inside the DH block.
    const headerPublicKey = currentRatchetKeyPair.publicKey;

    // Optional: AAD using header info
    const aadBuffer = stringToBytes( // Example AAD construction
        JSON.stringify({
            pk: bytesToHex(headerPublicKey),
            pn: currentState.prevSendMsgCounter,
            n: currentSendCounter,
        })
    );

    const ciphertext = await encryptAES(
        messageKeys.encKey,
        plaintext,
        messageKeys.iv,
        aadBuffer // Include AAD
    );

    // --- Construct Message ---
    const header: MessageHeader = {
        publicKey: headerPublicKey, // Our public key used for this epoch
        previousCounter: currentState.prevSendMsgCounter,
        messageCounter: currentSendCounter,
    };

    const isInitialMessage = currentState.sendMsgCounter === 0 && currentState.prevSendMsgCounter === 0 && !currentState.receivingChain;

    const message: RatchetMessage = {
        type: isInitialMessage ? MessageType.PRE_KEY : MessageType.NORMAL,
        header,
        ciphertext,
    };

    if (message.type === MessageType.PRE_KEY) {
        message.identityKey = nextState.identityPublicKey;
        // These IDs need real logic based on bundle negotiation
        message.preKeyId = 0; // Placeholder
        message.signedPreKeyId = 0; // Placeholder
    }

    return { message, nextState };
}


// --- Decryption Logic ---

/**
 * Creates a unique key for storing/retrieving skipped message keys based on header info.
 * Uses hex representation of the public key.
 * @param header The message header.
 * @returns A unique string key.
 */
function getSkippedKeyLookupKey(header: MessageHeader): string {
    const pkHex = bytesToHex(header.publicKey);
    return `${header.messageCounter}:${pkHex}`;
}


/**
 * Decrypts a received RatchetMessage using the current RatchetState.
 * Handles DH ratchet updates, Triple Ratchet enhancement, and skipped keys.
 * @param currentState The current RatchetState.
 * @param message The received RatchetMessage.
 * @returns A Promise resolving to { plaintext: ArrayBuffer, nextState: RatchetState }.
 */
export async function ratchetDecrypt(
    currentState: RatchetState,
    message: RatchetMessage
): Promise<{ plaintext: ArrayBuffer; nextState: RatchetState }> {

    let nextState = { ...currentState }; // Shallow copy
    let plaintext: ArrayBuffer | null = null;

    // --- Try Decrypting with Skipped Keys First ---
    const skippedKeyLookup = getSkippedKeyLookupKey(message.header);
    const skippedKeys = nextState.skippedRatchetKeys.get(skippedKeyLookup);

    if (skippedKeys) {
        console.debug(`Decrypting message N=${message.header.messageCounter} using skipped key.`);
        // Reconstruct AAD
        const aadBuffer = stringToBytes(JSON.stringify({
            pk: bytesToHex(message.header.publicKey),
            pn: message.header.previousCounter,
            n: message.header.messageCounter
        }));

        plaintext = await decryptAES(skippedKeys.encKey, message.ciphertext, skippedKeys.iv, aadBuffer);

        const updatedSkipped = new Map(nextState.skippedRatchetKeys);
        updatedSkipped.delete(skippedKeyLookup);
        nextState.skippedRatchetKeys = updatedSkipped;

        return { plaintext, nextState };
    }

    // --- Check for DH Ratchet Step ---
    let receivingChain = nextState.receivingChain;
    let performDH = false;

    if (!receivingChain) {
        // First message received (must be PreKey message handled by initializeRatchetReceiver usually)
        // Or first message after we initiated. Requires DH step.
        performDH = true;
    } else {
        // Check if sender's public key differs from the one we expect for the current chain
        const currentRemoteKey = nextState.theirRatchetKey;
        if (!currentRemoteKey) {
            throw new Error("Internal state error: Receiving chain exists but no remote ratchet key stored.");
        }
        if (!equalPublicKeys(currentRemoteKey, message.header.publicKey)) {
            performDH = true;
        }
    }

    if (performDH) {
         console.debug(`Performing DH ratchet step for received message N=${message.header.messageCounter}.`);
        // --- Store Skipped Message Keys from Old Chain ---
        if (receivingChain && nextState.theirRatchetKey) {
            const oldSkipped = new Map(nextState.skippedRatchetKeys);
            const currentChainIndex = receivingChain.chainIndex;
            const numToSkip = Math.min(message.header.previousCounter, MAX_SKIP);
            const oldRemotePubKey = nextState.theirRatchetKey; // Capture before update

            // Add keys currently in the receiving chain's skipped map
            for (const [idx, keys] of receivingChain.skippedMessageKeys.entries()) {
                 const headerKey = getSkippedKeyLookupKey({ publicKey: oldRemotePubKey, previousCounter: 0, messageCounter: idx });
                 oldSkipped.set(headerKey, keys);
                 console.debug(`Saving skipped key from old chain map for N=${idx}`);
            }

            // Derive and store future keys of the old chain up to Pn
            let tempChainKey = receivingChain.chainKey;
            for (let i = currentChainIndex; i < numToSkip; i++) {
                 const keys = await deriveMessageKeysFromChainKey(tempChainKey);
                 const headerKey = getSkippedKeyLookupKey({ publicKey: oldRemotePubKey, previousCounter: 0, messageCounter: i });
                 oldSkipped.set(headerKey, keys);
                 console.debug(`Saving future key from old chain derivation for N=${i}`);
                 tempChainKey = await advanceChainKey(tempChainKey);
            }
            nextState.skippedRatchetKeys = oldSkipped;
        } // End storing skipped keys

        // --- Perform DH Ratchet Calculation ---
        // Use our *current* enhanced private key and their *new* public key from header
        const dhOutput = computeDH(nextState.ourEnhancedPrivateKey, message.header.publicKey);
        const { newRootKey, newChainKey } = await performDHRatchetStep(nextState.rootKey, dhOutput);

        receivingChain = { chainKey: newChainKey, chainIndex: 0, skippedMessageKeys: new Map() };

        // Update state: new root key, new receiving chain, new remote key, reset recv counter
        nextState.rootKey = newRootKey;
        nextState.receivingChain = receivingChain;
        nextState.theirRatchetKey = message.header.publicKey; // Update to the key from the message header
        nextState.recvMsgCounter = 0;

        // --- Update Our Ratchet Key Pair (for next send) ---
        const nextRatchetKeyPair = generateECDHKeyPair();

        // --- Triple Ratchet Enhancement (Receiver Side) ---
        // Calculate the enhanced version of *our new* private key using the DH output *just calculated*.
        const nextEnhancedPrivateKey = await calculateEnhancedPrivateKey(
             nextRatchetKeyPair.privateKey, // Use the *newly generated* private key
             dhOutput
        );

        // Update state with the new key pair and the new enhanced key
        nextState.ourRatchetKeyPair = nextRatchetKeyPair;
        nextState.ourEnhancedPrivateKey = nextEnhancedPrivateKey;

        // Update previous sending counter and clear sending chain
        nextState.prevSendMsgCounter = nextState.sendMsgCounter;
        nextState.sendMsgCounter = 0;
        nextState.sendingChain = null; // Force recreation on next encrypt

    } // End DH Ratchet Step

    // --- Symmetric Ratchet Decryption ---
    if (!receivingChain) {
         throw new Error("Internal error: Receiving chain not available for decryption after DH check.");
     }

    const { messageKeys, nextChainState: updatedReceivingChain } = await getSymRatchetMessageKey(
        receivingChain,
        message.header.messageCounter
    );

    nextState.receivingChain = updatedReceivingChain;

     // --- AES Decryption ---
     const aadBuffer = stringToBytes(JSON.stringify({
         pk: bytesToHex(message.header.publicKey),
         pn: message.header.previousCounter,
         n: message.header.messageCounter
     }));

    plaintext = await decryptAES(messageKeys.encKey, message.ciphertext, messageKeys.iv, aadBuffer);

    if (plaintext === null) { // Should not happen if decryptAES doesn't return null
        throw new Error("Decryption succeeded but plaintext is null.");
    }

    return { plaintext, nextState };
}


// --- Helper functions for IdentityState (Placeholders - NEED IMPLEMENTATION) ---

async function getSignedPreKeyPair(identityState: IdentityState, keyId: number): Promise<ECKeyPair | null> {
    console.warn(`getSignedPreKeyPair for ID ${keyId} is not implemented`);
    // Example: return identityState.signedPreKeys.get(keyId) || null;
    return identityState.signedPreKeys?.get(keyId) ?? null; // Needs IdentityState.signedPreKeys to be populated
}

async function getOneTimePreKeyPair(identityState: IdentityState, keyId: number): Promise<ECKeyPair | null> {
    console.warn(`getOneTimePreKeyPair for ID ${keyId} is not implemented`);
    // Example:
    // const keyPair = identityState.preKeys.get(keyId);
    // if (keyPair) {
    //     // IMPORTANT: Delete the key after use
    //     identityState.preKeys.delete(keyId);
    //     return keyPair;
    // }
    // return null;
     const keyPair = identityState.preKeys?.get(keyId);
     // Deleting from the map passed by value won't work here.
     // This highlights a challenge of purely functional state management with one-time keys.
     // A real implementation needs a way to signal that this key was used and update
     // the persistent IdentityState accordingly.
     // For now, just return it without deletion.
     return keyPair ?? null; // Needs IdentityState.preKeys to be populated
}

