# A More Complete Analysis of the Signal Double Ratchet Algorithm 

Alexander Bienstock ${ }^{1(\boxtimes)}$, Jaiden Fairoze ${ }^{2}$, Sanjam Garg ${ }^{2,3}$, Pratyay Mukherjee ${ }^{4}$, and Srinivasan Raghuraman ${ }^{5}$<br>${ }^{1}$ New York University, New York, USA<br>abienstock@cs.nyu.edu<br>${ }^{2}$ UC Berkeley, Berkeley, USA<br>${ }^{3}$ NTT Research, Sunnyvale, USA<br>${ }^{4}$ Swirlds Labs, Dallas, USA<br>${ }^{5}$ Visa Research, Palo Alto, USA


#### Abstract

Seminal works by Cohn-Gordon, Cremers, Dowling, Garratt, and Stebila [EuroS\&P 2017] and Alwen, Coretti and Dodis [EUROCRYPT 2019] provided the first formal frameworks for studying the widely-used Signal Double Ratchet (DR for short) algorithm.

In this work, we develop a new Universally Composable (UC) definition $\mathcal{F}_{\mathrm{DR}}$ that we show is provably achieved by the DR protocol. Our definition captures not only the security and correctness guarantees of the DR already identified in the prior state-of-the-art analyses of Cohn-Gordon et al. and Alwen et al., but also more guarantees that are absent from one or both of these works. In particular, we construct six different modified versions of the DR protocol, all of which are insecure according to our definition $\mathcal{F}_{\mathrm{DR}}$, but remain secure according to one (or both) of their definitions. For example, our definition is the first to fully capture CCA-style attacks possible immediately after a compromise - attacks that, as we show, the DR protocol provably resists, but were not fully captured by prior definitions.

We additionally show that multiple compromises of a party in a short time interval, which the DR is expected to be able to withstand, as we understand from its whitepaper, nonetheless introduce a new non-trivial (albeit minor) weakness of the DR. Since the definitions in the literature (including our $\mathcal{F}_{\text {DR }}$ above) do not capture security against this more nuanced scenario, we define a new stronger definition $\mathcal{F}_{\text {TR }}$ that does.

Finally, we provide a minimalistic modification to the DR (that we call the Triple Ratchet, or TR for short) and show that the resulting protocol securely realizes the stronger functionality $\mathcal{F}_{\text {TR }}$. Remarkably, the modification incurs no additional communication cost and virtually no additional computational cost. We also show that these techniques can be used to improve communication costs in other scenarios, e.g. practical Updatable Public Key Encryption schemes and the re-randomized TreeKEM protocol of Alwen et al. [CRYPTO 2020] for Secure Group Messaging.


The full version [8] is available as entry 2022/355 in the IACR eprint archive.

[^0]
## 1 Introduction

Background. The Signal protocol is by far the most popular end-to-end secure messaging (SM) protocol, boasting of billions of users. Based on the Off-TheRecord protocol [10], the core underlying technique of the Signal protocol is commonly known as the Double Ratchet (DR) algorithm. The DR is beautifully explained in the whitepaper [40] authored by the creators of Signal, Marlinspike and Perrin. The whitepaper also outlines the desired security properties of the DR, and provides intuition on the design rationale for achieving them. Indeed, in addition to standard security against an eavesdropper who may modify ciphertexts, the DR attempts to achieve (i) post-compromise security (PCS) and forward secrecy (FS) with respect to leakages of secret state, (ii) resilience to bad randomness, and (iii) immediate decryption (all at the same time). PCS requires the conversation to naturally and quickly recover security after a leakage on one of the (or both) parties, as long as the affected parties have good randomness (and the adversary remains passive while such recovery occurs) [20]. FS requires past messages to remain secure even after a leakage on one of the (or both) parties. Resilience to bad randomness requires that as long as both parties' secret states are secure (i.e., PCS has been achieved after any corruptions), then the conversation should remain secure, even if bad randomness is used in crafting messages. Finally, immediate decryption requires parties to-immediately upon reception of ciphertexts-obtain underlying plaintexts and place them in the correct order in the conversation, even if they arrive arbitrarily out of order and if some of them are completely lost by the network (the latter is also known as message-loss resilience).

However, despite the elegance and simplicity of the Double Ratchet, capturing its security turned out to be not so straightforward. The first formal analysis of the DR protocol (in fact, the whole Signal protocol) was provided by Cohn-Gordon et al. in EuroS\&P $2017[18,19]$ (referred to as CCD $^{+}$henceforth). However, this analysis left open several questions about the cryptographic security and correctness achieved by the DR. Following in the footsteps of $\mathrm{CCD}^{+}$, a more generic and comprehensive security definition of the DR was provided by Alwen et al. in Eurocrypt 2019 [3] (referred to as ACD henceforth), with close focus on the immediate decryption property of the DR protocol. They provided a modular analysis with respect to game-based definitions proposed therein. Indeed, they introduced new abstract primitives and composed them into SM protocols (including the DR itself) that capture the above properties: Continuous Key Agreement (CKA), Forward-Secure Authenticated Encryption with Associated Data (FS-AEAD), and PRF-PRNGs. While the works of CCD ${ }^{+}$ and ACD significantly improved our understanding of the DR, as we observe in this work, both definitional frameworks do not capture some of its security and functionality properties.

### 1.1 Our Contributions

In this work, our key aim is to develop a formal definitional framework that captures the security and correctness properties of the DR protocol as completely as possible. Moreover, we aspire for definitions that are simple to state and easy to build on (e.g., imagine executing a Private Set Intersection Protocol on top of the DR). More specifically:

- New Definitional Framework for the DR: We provide a new definition $\mathcal{F}_{\text {DR }}$ for the DR protocol, in the Universal Composability [14] (UC) framework. Our definition captures all of the security and correctness guarantees of the DR provided by ACD's and $\mathrm{CCD}^{+}$'s definitions, but also more guarantees that are absent from one or both of these works. To demonstrate this, we construct six different (albeit somewhat contrived) modified versions of the DR protocol, all of which are insecure according to our definition, but remain secure according to ACD's and/or $\mathrm{CCD}^{+}$'s definition. Some of these transformations are indeed based on analyzed (weaker) DR variants in the literature, while others are based on novel observations. For example, our definition is the first to fully capture CCA-style attacks that become possible on the DR immediately after a party has been compromised-attacks that, as we show, the DR provably resists, but were not fully captured by prior definitions. We provide an overview of our new definition's advantages in Sect.1.3.

Finally, we prove that the DR protocol, as it is described in the whitepaper [40] (in its strongest form), securely realizes our ideal functionality $\mathcal{F}_{\mathrm{DR}}$. Our proof is modular and proceeds by expanding on ACD's modular definitional framework (see Appendix E). Note that we model part of the underlying AEAD of the DR using a programmable ideal cipher to prove security in the UC setting where an adversary can corrupt a party while a (heretofore secure) ciphertext is in transit.

- Non-trivial (albeit minor) weakness of the DR: We find that multiple compromises of a party in a short time interval, which the DR should be able to withstand, as we understand from its whitepaper, nonetheless introduce a new non-trivial (albeit minor) weakness of the DR. This weakness is allowed in the definitions of both ACD and $\mathrm{CCD}^{+}$, as well as $\mathcal{F}_{\mathrm{DR}}$, so we provide a new stronger definition $\mathcal{F}_{\text {TR }}$ that does not allow it. We summarize this compromise scenario in Sect.1.4.
- Achieving stronger security: Finally, we complement the above weakness by providing a minimalistic modification to the DR and prove the resulting protocol secure according to the stronger definition $\mathcal{F}_{\text {TR }}$. We call this new protocol the Triple Ratchet (TR) as it adds another "mini ratchet" to the public ratchet in the DR Protocol. Remarkably, the modification incurs no additional communication cost and virtually no additional computational cost. We provide an overview of the TR in Sect.1.5.

We believe that the techniques realized here are also likely to find other applications. For instance, in Appendix F, we show that our techniques
can be used to improve current practical Updatable Public Key Encryption (UPKE) constructions [4,34], reducing their communication cost by an additive factor of $|G|$, where $|G|$ is the number of bits needed to represent the size of the (CDH-hard) group used in the construction, without any additional computational cost. Furthermore, the technique yields an improvement to the communication cost of the re-randomized TreeKEM (rTreeKEM) protocol of Alwen et al. [4]-specifically, improving the communication cost by up to roughly an additive factor of $|G| \cdot n$, where $n$ is the number of users in the group.

### 1.2 High-Level Summary of the Double Ratchet and Its Security Properties

Before elaborating on our results in the subsequent sections, we first give a highlevel overview of the Signal Double Ratchet and its security properties which we capture in our definition. For another detailed description we refer to the Double Ratchet whitepaper [40]. Readers familiar with the Double Ratchet algorithm could easily skip this section.

We note that although we here describe the double ratchet specifically in terms of its real-world implementation [40], our paper still breaks it down into modular pieces which can be instantiated in several different ways, as in ACD. For the purpose of our paper, we assume that the two participants $P_{1}$ and $P_{2}$ share a common secret upon initialization. In Signal, this is achieved via the X3DH key exchange protocol [41], but we consider this out of scope for our study of the double ratchet. Using their initial shared secret, $\mathrm{P}_{1}$ and $\mathrm{P}_{2}$ can derive the initial root key $\sigma$ which seeds the public ratchet. Furthermore, upon initialization $\mathrm{P}_{2}$ also holds some secret exponent $x_{0}$ and $\mathrm{P}_{1}$ holds the corresponding public value $g^{x_{0}}$. Once the initialization process completes, the ratcheting session begins.

At its core, the double ratchet has two key components: the outer public-key ratchet, and the inner symmetric-key ratchet (often referred to as simply the public and symmetric ratchets, respectively). ACD abstract out the symmetric ratchet as their FS-AEAD primitive, the update mechanism of the public ratchet as their PRF-PRNG primitive, and the means by which shared secrets are produced to update the public ratchet as their CKA primitive. The goal of the double ratchet is to provide distinct message keys to encrypt/decrypt each new message. For each message the same message key is derived by both parties using a symmetric chain key which itself is derived from the aforementioned root key. Naturally, this results in a key hierarchy with the root key at the top, chain keys at an intermediate layer, and message keys at the bottom. Observe a graphical depiction of this hierarchy in Fig. 1. In the Signal double ratchet, Diffie-Hellman key exchange is used to "ratchet forward" the root key, which can then be used to establish corresponding symmetric chain keys. Message keys are then derived from the current (newest) chain key, where chain keys are updated deterministically such that multiple messages can be sent in a row before
a response, and no matter which of these messages is the first to arrive, the recipient can always compute its corresponding message key immediately. We now introduce the concept of asynchronous epochs before describing the two ratchets and the primary properties which they achieve:

Asynchronous Sending Epochs. In the double ratchet, the parties $\mathrm{P}_{1}$ and $\mathrm{P}_{2}$ asynchronously alternate sending messages in epochs (as termed in [3]): Assume that $P_{1}$ starts the conversation, sending in epoch 1 at least one message. Then once $P_{2}$ receives one of these messages, she sends messages in epoch 2. Furthermore, once $P_{1}$ receives one of these message, she starts epoch 3 , and so on. We emphasize that these sending epochs are asynchronous - for example, even if $P_{2}$ has started sending in epoch 2 , if $P_{1}$ has not yet received any such epoch 2 messages and wants to send new messages, she will still send them in epoch 1. Not until she finally receives one of $P_{2}$ 's epoch 2 messages will she send new messages in epoch 3 .

Public Ratchet. The public ratchet forms the backbone of the double ratchet algorithm. Parties update the root key using public-key cryptography (i.e. DiffieHellman secrets) every time a new epoch is initiated: if $P_{1}$ wishes to start a new epoch, she must first update the root key using the Diffie-Hellman public value from $\mathrm{P}_{2}$ 's latest epoch (or initialization). After deriving a new chain key from the root key, $P_{1}$ can send multiple separate messages in a row-this involves deriving a new message key for each message via the symmetric ratchet, as explained below.

We now describe the root key update process in more detail. To start a new epoch $t, \mathrm{P}_{1}$ samples a new private exponent $x_{t}$ and corresponding public value $g^{x_{t}}$. Next, she uses the public value received from $P_{2}$ 's latest epoch (or initialization), say $g^{x_{t-1}}$, to compute a shared secret $\left(g^{x_{t-1}}\right)^{x_{t}}=g^{x_{t-1} x_{t}}$. Then, $\mathrm{P}_{1}$ uses a two-input Key Derivation Function (KDF) to update the current root key and derive a new chain key in one go. That is, she computes $\left(\sigma_{t}, w_{t, 1}\right) \leftarrow \operatorname{KDF}\left(\sigma_{t-1}, g^{x_{t-1} x_{t}}\right)$. Observe that even if $\mathrm{P}_{1}$ 's state was leaked before this update, as long as the parties used good randomness in sampling their Diffie-Hellman keys, the new root key and chain key will be secure. This is the key to achieving PCS. Symmetrically, even if $\mathrm{P}_{1}$ uses bad randomness when performing this update, as long as if $\sigma_{t-1}$ was secure, then the new root key and chain key will be secure. Furthermore, root keys are clearly forward secret, from the security of the KDF and the fact that new Diffie-Hellman secrets are sampled independently of past ones.
$\mathrm{P}_{1}$ includes in every message of the new epoch the fresh public share $g^{x_{t}}$ to allow $\mathrm{P}_{2}$ to compute the new shared secret $g^{x_{t-1} x_{t}}$ that is used to update the root key, no matter which message of the epoch she receives first. This in part is what provides for immediate decryption (and message loss resilience). When $\mathrm{P}_{2}$ receives a message in $\mathrm{P}_{1}$ 's new epoch, she recomputes the same above steps, i.e. she computes $\sigma_{t}$ by first computing $\left(g^{x_{t}}\right)^{x_{t-1}}=g^{x_{t-1} x_{t}}$ where $x_{t-1}$ is $\mathrm{P}_{2}$ 's own private share, followed by the same KDF computation. Once $\mathrm{P}_{2}$ wishes to start her own new epoch, she generates another Diffie-Hellman pair $\left(x_{t+1}, g^{x_{t+1}}\right)$ to
![](https://cdn.mathpix.com/cropped/2025_02_24_f19b2c18609a278e5fd2g-06.jpg?height=460&width=1183&top_left_y=181&top_left_x=190)

Fig. 1. Sample Double Ratchet key evolution. In this depiction, $P_{1}$ sends and $P_{2}$ receives in epoch 1 , followed by $P_{2}$ sending and $P_{1}$ receiving in epoch 2, and so on. As explained in the main body, initial symmetric chain keys $w_{i, 1}$ for each epoch $i$ are derived first by the sender, then also by the receiver, using the shared root keys $\sigma_{i}$ and asynchronously exchanged shared secrets (via DDH). Then, updated symmetric chain keys $w_{i, j}$ and message keys $K_{i, j}$ are derived deterministically from $w_{i, 1}$.
ratchet the root key forward $\left(\sigma_{t+1}, w_{t+1,1}\right) \leftarrow \operatorname{KDF}\left(\sigma_{t}, g^{x_{t} x_{t+1}}\right)$. Essentially, $\mathrm{P}_{2}$ has refreshed her component of the Diffie-Hellman shared secret while reusing $P_{1}$ 's value from the previous epoch. Now, when $P_{1}$ receives a message for this epoch and again wishes to start a new one, she would similarly need to sample a new Diffie-Hellman share $x_{t+2}$. This process can continue asynchronously for as long as the session is active.

Symmetric Ratchet. The main purpose of the symmetric ratchet is to produce single-use symmetric keys for message encryption. When a party wishes to send (or receive) the next ( $i$ th) message in some epoch $t$, they derive a distinct message key $K_{t, i}$ from the symmetric chain key $w_{t, i}$ and simultaneously update the chain key. This is done by applying a KDF as follows: $\left(w_{t, i+1}, K_{t, i}\right) \leftarrow \operatorname{KDF}\left(w_{t, i}\right)$ (if the KDF requires two inputs, a fixed value may be used to fill the other input). Observe that the symmetric ratchet is clearly forward secret from the security of the KDF. Note however that the symmetric ratchet does not have PCS due to its deterministic nature.

So, if $P_{1}$ just started a new epoch then she first computes initial symmetric chain key $w_{t, 1}$ for the epoch as above. To derive a message key, $\mathrm{P}_{1}$ puts this new chain key through the KDF to compute $\left(w_{t, 2}, K_{t, 1}\right) \leftarrow \operatorname{KDF}\left(w_{t, 1}\right)$. If $\mathrm{P}_{1}$ wishes to send a second message, then she can derive $\left(w_{t, 3}, K_{t, 2}\right) \leftarrow \operatorname{KDF}\left(w_{t, 2}\right)$. When $P_{2}$ receives these messages from $P_{1}$, she can repeat the key derivation in the same way as $P_{1}$ and use the subsequent message keys to decrypt the messages, no matter the order in which they arrive. The deterministic nature of the symmetric ratchet, along with including the public ratchet values in every message as above, provides immediate decryption.

### 1.3 High-Level Summary of Our DR Definition's Strength over Prior Notions

In Sect. 2 we fully formalize our new definition for the DR in the UC framework, $\mathcal{F}_{\mathrm{DR}}$, and provide thorough discussion on it. Then in Appendix E, we show that the DR UC-realizes $\mathcal{F}_{\mathrm{DR}}$ (in the programmable ideal cipher model). Intuitively, $\mathcal{F}_{\text {DR }}$ captures all of the properties described in the last section, including all of those captured by the definitions of ACD and $\mathrm{CCD}^{+}$. Here we emphasize several properties which $\mathcal{F}_{\text {DR }}$ guarantees, but at least one of ACD's and CCD ${ }^{+}$'s definitions do not. We do so by providing six distinct transformations to the original DR protocol (denoted as $T_{i}(\mathrm{DR})$ for $i \in[6]$ ), showing their natural vulnerabilities here, and their insecurity according to $\mathcal{F}_{\mathrm{DR}}$, but security according to at least one of ACD's (transformations $1-4$ ) and $\mathrm{CCD}^{+}$'s (transformations $4-6)$ definitions. We show this formally in Appendix D.2. Although some of these transformations may be seen as artificial, they emphasize that our definition is stronger than those of ACD and $\mathrm{CCD}^{+}$. Below we use the formalization of symmetric and public ratchets as done by ACD and also adapted by us - the symmetric ratchet is abstracted out as an $F S-A E A D$ scheme and the public ratchet as a $C K A$ scheme. We defer these definitions to Sect. 3 and Appendix B.
$T_{1}$ : Postponed FS-AEAD Key Deletion: This transformation slightly modifies the handling of symmetric ratchet secrets. In particular, when a party receives a new message for its counterpart's next epoch, it does not immediately delete its (no longer needed) symmetric ratchet secrets from its previous sending epoch. Instead, it waits to delete these secrets until it starts its next sending epoch (i.e., sends its next message). In that case, an injection attack can be launched as follows: only focusing on the symmetric ratchet, suppose that for a sending epoch $t, \mathrm{P}_{1}$ derives $\left(w_{t, 2}, K_{t, 1}\right) \leftarrow \operatorname{KDF}\left(w_{t, 1}\right)$ and sends an encrypted message using $K_{t, 1}$, that is then received by $\mathrm{P}_{2}$. Then $\mathrm{P}_{2}$ sends a message in epoch $t+1$, which is received by $P_{1}$. Observe that unlike in (the strongest version of) the DR, $T_{1}(\mathrm{DR})$ keeps $w_{t, 2}$ in $\mathrm{P}_{1}$ 's memory even after receiving this epoch $t+1$ message from $\mathrm{P}_{2}$. Now if $\mathrm{P}_{1}$ is compromised then the attacker obtains $w_{t, 2}$. Using this it can now launch an injection attack for $P_{1}$ 's sending epoch $t$ (not just $P_{1}$ 's next sending epoch, $t+2$ ) by encrypting any arbitrary message of its choice using the next message key $\left(\cdot, K_{t, 2}\right) \leftarrow \operatorname{KDF}\left(w_{t, 2}\right)$ and sending that to $\mathrm{P}_{2}$. Note that each time a sending epoch is started in the protocol, the information about how many messages were sent in the immediately past sending epoch is included. Nonetheless, that does not thwart this attack, because it is launched even before $P_{1}$ starts the next sending epoch.

Although this transformation is perhaps artificial, one can imagine scenarios in which the relative timing of messages sent by the two parties is important. Perhaps more importantly, it is clearly less secure than the standard (most secure version of) DR, but, remarkably, the version described by ACD is indeed $T_{1}(\mathrm{DR})$. Furthermore, as evident by ACD's security proof, their definition therefore does
not require resistance against this attack; intuitively making our (and $\mathrm{CCD}^{+}$'s) definition stronger than theirs in this respect.
$T_{2}$ : Postponed CKA Key Deletion: A similar problem arises if the keys from the public ratchet are kept for too long. The transformed protocol works as follows: suppose that in starting a new sending epoch $t, \mathrm{P}_{2}$ samples a secret exponent $x_{t}$ and combines it with the public ratchet message of $\mathrm{P}_{1}$ 's prior sending epoch, $g^{x_{t-1}}$, to compute $I_{t}=g^{x_{t-1} x_{t}}$. Then, $\mathrm{P}_{2}$ proceeds to send several messages using $I_{t}$ (and the root key for the KDF, as described in Sect.1.2) as normal. When receiving a message for the first time in sending epoch $t$ of $\mathrm{P}_{2}, \mathrm{P}_{1}$ uses her stored secret exponent $x_{t-1}$ and combines it with $\mathrm{P}_{2}$ 's public ratchet message $g^{x_{t}}$ to compute $I_{t}$. However, at this point, instead of deleting $I_{t}$ (as done in the normal DR protocol), $\mathrm{P}_{1}$ saves it in $T_{2}(\mathrm{DR})$. Now assume that $\mathrm{P}_{1}$ receives all of $\mathrm{P}_{2}$ 's epoch $t$ messages. Then, when $\mathrm{P}_{1}$ again switches to a new sending epoch she generates a new $I_{t+1}$ (deleting the old $I_{t}$ ). An attack can be executed on $T_{2}$ (DR), by simply corrupting $\mathrm{P}_{1}$ before the start of epoch $t+1$, and then using the leaked $I_{t}$ to decrypt the already delivered messages sent by $\mathrm{P}_{2}$ in epoch $t$ - thus breaking forward security. Note: this also requires another corruption of $\mathrm{P}_{2}$ before she sends messages in the attacked epoch $t$, to obtain the root key for the KDF. ACD's definition explicitly prevents querying the challenge oracle immediately after corruptions, and thus does not require resistance against this attack. $\mathrm{CCD}^{+}$'s model does explicitly require resistance against this attack. This transformation may seem artificial, but clearly allowing the adversary to decrypt old messages should not be allowed in any formal model of the DR, and in fact is not allowed in $\mathcal{F}_{\text {DR }}$.
$T_{3}$ : Eager CKA Randomness Sampling: If the secret-exponent of a public-ratchet is sampled too early, then that makes the protocol vulnerable. For example, consider $T_{3}(\mathrm{DR})$ in which $\mathrm{P}_{1}$ samples the exponent $x_{t}$ for the next sending epoch $t$ when still in receiving epoch $t-1$. An attacker may compromise $\mathrm{P}_{1}$ to obtain $x_{t}$ (and the root key) at this stage and use that to decrypt the messages sent in the next epoch $t$, thereby breaking PCS. ACD's definition does not require resistance against this attack, while $\mathcal{F}_{\mathrm{DR}}$ does, because their definition does not allow querying the challenge oracle immediately after corruptions. It is worth pointing out that the Double Ratchet whitepaper [40] and $\mathrm{CCD}^{+}$present $T_{3}(\mathrm{DR})$ and its early sampling as their primary description of the DR, though the whitepaper later suggests deferring randomness sampling until actually sending for better security, which we choose to model. However, the security model itself of $\mathrm{CCD}^{+}$ only analyzes the key exchange component of the DR and we believe that it could indeed be composed with an AEAD scheme to avoid the weakness of $T_{3}(\mathrm{DR})$. However, this needs to be carefully done, and not according to their description of the full DR protocol.
$T_{4}$ : Malleable Ciphertexts: If the protocol does not provide a strong nonmalleability guarantee, then the DR protocol could suffer from a mauling attack according to our weaker definition $\mathcal{F}_{\mathrm{DR}}$. More specifically, if the root key is leaked,
and $T_{4}(\mathrm{DR})$ uses a weak mechanism to update the public ratchet (note: the DR public ratchet should provide PCS here), there may exist attacks which, for example, can successfully maul DR ciphertexts encrypting $m$ into new ones that decrypt to $m+1$. This becomes evident when we prove the DR protocol secure according to $\mathcal{F}_{\mathrm{DR}}$, which is required to protect against such an attack, as we need to rely on such a non-malleability property. Indeed, the DR seems to require modelling the public ratchet KDF as a random oracle and that the Strong Diffie-Hellman assumption $(\mathrm{StDH})$ is secure (i.e., given random and independent $g^{a}, g^{b}$, and oracle access to $\mathbf{d d h}\left(g^{a}, \cdot, \cdot\right)$ which on input group elements $X, Y$ checks if $X^{a}=Y$, it is hard to compute $g^{a b}$ ), in order to realize $\mathcal{F}_{\mathrm{DR}}$. To provide evidence for this requirement: the ciphertexts and key material known to the adversary in the above scenario are almost identical to that of Hashed ElGamal encryption, for which all analyses of its CCA-security of which we are aware use the same assumptions [1,21,39]. We do not rule out a security proof from weaker assumptions, however, it seems that using a group in which only DDH is hard, and not, for example, StDH , for the public ratchet could lead to an attack like the above. ACD's definition does not require resistance against such an attack since it does not allow injections after corruptions; therefore, their security proof only relies on DDH.
$\mathrm{CCD}^{+}$'s definition also does not completely cover mauling attacks, since it only analyzes the key exchange component of the DR, not any actual message transmission. Therefore, if one composes a key exchange protocol secure with respect to $\mathrm{CCD}^{+}$'s definition with a non-authenticated encryption scheme, it would not provide the non-malleability guarantees required by $\mathcal{F}_{\text {DR }}$.
$T_{5}$ : CKA Bad Randomness Plaintext Trigger: The DR is very resilient to attacks against its source of randomness. However, in $T_{5}(\mathrm{DR})$, if a party samples a certain string of random bits, say the all-0 string, then it (rather artificially) sends the rest of its messages in the conversation as plaintext. In our (and ACD's) model, which require security even if the adversary can supply the parties with random bits each time they attempt to sample randomness, such a protocol is clearly insecure. However, $\mathrm{CCD}^{+}$'s model only allows randomness reveals of uniformly sampled random bits. Thus sampling the all-0 string occurs with negligible probability (if we assume bit strings of poly $(\lambda)$ length), so security in $\mathrm{CCD}^{+}$'s model is retained. Although this attack is quite artificial, [5] note that attacks on randomness sources (e.g., [31]) and/or generators (e.g., [17,51]) are not captured by randomness reveals, but are captured by randomness manipulation as in our model. Furthermore, [5] show that including randomness manipulations has a concrete effect on protocol construction, particularly in Secure Messaging.
$T_{6}$ : Removed Immediate Decryption: Finally, $T_{6}(\mathrm{DR})$ changes the DR to include the public ratchet message as part of only the first ciphertext of an epoch. It is thus pretty simple to violate the immediate decryption property required by our ideal functionality: First have $\mathrm{P}_{1}$ send two messages $m_{1}, m_{2}$ in a new epoch $t$, generating ciphertexts $c_{1}$ and $c_{2}$. Then, attempt to deliver $c_{2}$ to $\mathrm{P}_{2}$ (before $c_{1}$ ). Since $c_{2}$ does not include the public ratchet message of the epoch, $\mathrm{P}_{2}$ will be unable to decrypt it to obtain $m_{2}$. While $\mathcal{F}_{\text {DR }}$ does in fact require immediate
decryption, $\mathrm{CCD}^{+}$'s model does not require it (nor correctness more generally), so $T_{6}(\mathrm{DR})$ satisfies all formal requirements of their model. ACD's model does in fact require immediate decryption.

Although this too may be an artificial transformation, immediate decryption is an important practical property of the DR, and one of the DR's main novelties is obtaining immediate decryption at the same time as FS and PCS. Furthermore, properly modelling immediate decryption allows subsequent work to understand it, and further improve upon the DR with the requirement in mind. Indeed, many of the works which we are aware of [7,24,32,34,45], besides [3], which try to improve the DR do not consider immediate decryption in their security models or constructions, arguably thrusting these works outside of the practical realm.

### 1.4 High-Level Summary of the DR's Minor Weakness

Here we show a scenario that introduces a new non-trivial (albeit minor) weakness of the DR which demonstrates a gap between the security guarantees that the DR should achieve according to our understanding of its whitepaper, and those which it actually does achieve. The attack utilizes two compromises of a party in a short time interval, and stems from the fact that a party needs to hold on to the secret exponent $x_{t}$ for the public ratchet that it generates in a sending epoch $t$ until it receives a message from its counterpart's next sending epoch $t+1$. Indeed secret exponent $x_{t}$ is needed until this point because the other party uses its public component to encrypt messages in epoch $t+1$. For example, consider a setting in that party $\mathrm{P}_{1}$ is about to start a sending epoch $t$. At this point $\mathrm{P}_{1}$ 's state has $g^{x_{t-1}}$ and $\mathrm{P}_{2}$ has $x_{t-1}$. Now when the sending epoch
commences, $\mathrm{P}_{1}$ samples fresh secret (random) exponent $x_{t}$ and combines that with $g^{x_{t-1}}$ to derive the CKA key $I_{t}=g^{x_{t-1} x_{t}}$, which she then combines with the root key $\sigma_{t}$ to derive first the symmetric chain key $w_{t, 1}$, followed by message key $K_{t, 1}$. Note that if $x_{t}$ is truly random, then $I_{t}$ and thus $w_{t, 1}$ and all subsequent message keys $K_{t, i}$ should be secure. In this epoch $\mathrm{P}_{1}$ sends $g^{x_{t}}$ to $\mathrm{P}_{2}$, who then derives the same key $I_{t}$ by computing $\left(g^{x_{t}}\right)^{x_{t-1}}$, and subsequently $K_{t, 1}$. In the next epoch, $\mathrm{P}_{2}$ becomes a sender. Then $\mathrm{P}_{2}$ samples a fresh $x_{t+1}$ to derive a new CKA key $I_{t+1}=\left(g^{x_{t}}\right)^{x_{t+1}}$ and sends $g^{x_{t+1}}$ to $\mathrm{P}_{1}$. Now, $\mathrm{P}_{1}$ needs to compute $I_{t+1}$ as $\left(g^{x_{t+1}}\right)^{x_{t}}$. To execute this step $\mathrm{P}_{1}$ must have stored $x_{t}$ throughout its sending epoch. The attack exploits this by compromising $P_{1}$ twice in a short interval:

- first compromise $P_{1}$ before starting the sending epoch $t$ to obtain the root key $\sigma_{t}$;
- then compromise $P_{1}$ at any time after she sends a few messages (at least one), but before she receives any epoch $t+1$ messages, to obtain $x_{t}$, and thus $I_{t}$;
and then combine $\sigma_{t}$ and $I_{t}$ to derive $w_{t, 1}$, given which all messages within $\mathrm{P}_{1}$ 's sending epoch $t$ are vulnerable, including the ones that were sent between the two corruptions. Intuitively, this breaks PCS with respect to the first corruption,
since as noted above, if $x_{t}$ is truly random, then the corresponding message keys should be secure, as well as FS with respect to the second corruption. For more details we refer to Appendix C.2.

In Sect. 2, we provide a new ideal functionality, $\mathcal{F}_{\mathrm{TR}}$, that strengthens $\mathcal{F}_{\mathrm{DR}}$ in order to capture security against the above compromise scenario. We note that both the definitions of ACD and $\mathrm{CCD}^{+}$also did not capture this scenario.

### 1.5 High-Level Summary of the Triple Ratchet

Finally, we provide a minimalistic modification of the DR, which we call the Triple Ratchet protocol, or simply TR, with virtually no overhead over the DR. This protocol is secure against the compromise scenario provided in the previous section and thus realizes our stronger ideal functionality, $\mathcal{F}_{\text {TR }}$. The TR protocol modifies the underlying public ratchet in a way that the sampled secret exponent is deterministically updated after starting a sending epoch; thus, adding a "mini ratchet" on top of Signal's public ratchet. In particular, using the notation from above, in the modified public ratchet, a party (say $\mathrm{P}_{1}$ ) after sampling secret exponent $x_{t}$, and deriving $I_{t}=\left(g^{x_{t-1}}\right)^{x_{t}}$, sends $g^{x_{t}}$ as the public ratchet message, but stores $x_{t}^{\prime}=x_{t} \cdot \mathrm{H}\left(I_{t}\right)$ instead of $x_{t}$. Once $\mathrm{P}_{2}$ receives $g^{x_{t}}$, she also derives $I_{t}$ and computes $g^{x_{t}^{\prime}}=g^{x_{t} \cdot \mathrm{H}\left(I_{t}\right)}$ that she uses for the next public ratchet. In particular, in the next epoch when $P_{2}$ becomes the sender, she samples a fresh secret exponent $x_{t+1}$, and uses the key $I_{t+1}=g^{x_{t}^{\prime} x_{t+1}} . \mathrm{P}_{2}$ sends $g^{x_{t+1}}$, upon receiving which $\mathrm{P}_{1}$ can compute $I_{t+1}$ as $\left(g^{x_{t+1}}\right)^{x_{t}^{\prime}}$, but $\mathrm{P}_{2}$ only stores $x_{t+1}^{\prime}=x_{t+1} \cdot \mathrm{H}\left(I_{t+1}\right)$, and so on. Assuming H to be a random oracle, or instead, circular-security of ElGamal encryption, we can show that given $x_{t}^{\prime}, I_{t}$ is completely hidden, rendering the attack of the previous section useless. Note that the communication cost remains the same for the modified protocol, that is one group element. The computation cost increases only slightly, specifically exactly once per epoch. We also note that, the alternate CKA scheme based on generic KEMs proposed by [3] seems to achieve this security too, albeit with doubling the communication cost.

Furthermore, as we show in Appendix F, our efficient modification can also be applied to practical UPKE schemes, reducing their communication by an additive factor of $|G|$, where $|G|$ is the number of bits needed to represent the size of the (CDH-hard) group used in the schemes. Using the modified UPKE scheme, we can reduce the communication of, e.g., the rTreeKEM scheme [4] used for Secure Group Messaging by an additive factor of $|G| \cdot n$, where $n$ is the number of users in the group.

### 1.6 Other Related Work

Canetti, Jain, Swanberg, and Varia [16] also recently studied the security of the Signal protocol in the UC framework. Kobeissi, Bhargavan, and Blanchet [37] use automated verification tools to provide symbolic and computational proofs for a simplified variant of the Signal protocol.

Following the first formal analysis of Signal by $\mathrm{CCD}^{+}$, researchers proposed a number of protocols that provided stronger security than the DR $[5,7,25,32$, $34,45]$. ACD however observed that in the process of strengthening security, all such protocols suffer from steep efficiency costs and loss of immediate decryption, rendering these protocols impractical for real-world use.

Jost, Maurer and Mularczyk [35] analyzed ratcheting with the Constructive Cryptography framework [42]. They aimed to capture the security and composability of various sub-protocols, such as FS-AEAD, used in the construction of larger ratcheting protocols.

More recently, there has also been work on the X3DH key exchange protocol used in Signal, providing generalized frameworks that allow for post-quantum secure versions $[11,13,22,30]$, and analyzing its offline deniability guarantees [11, $22,30,48-50]$.

### 1.7 Summary of the Rest of the Paper

In Sect. 2 we provide our UC-based ideal functionalities in Fig. 2. We put a lot of discussions around it for reader's convenience, and along the way explain why the transformations of Sect. 1.3 are insecure according to our definitions. In Sect. 3, we define the CKA primitive (capturing the public ratchet) and formally detail the two public ratchets used in the DR and TR (as described in Sect.1.5), respectively, while only proving secure the latter.

Due to space limitations we defer the rest of the technical sections to the supplementary body. In Appendix A we provide the preliminaries containing mostly definitions borrowed from literature. In Appendix B we provide the other building blocks required for the DR (and TR), i.e., (i) we explain the (informal) properties required from the KDF used for the public ratchet (which we model as a random oracle to handle corruptions with messages in-transit; see Appendix B. 1 for more discussion on this), (ii) we introduce FS-AEAD (formalizing the symmetric ratchet part), and (iii) we formally provide additional details on CKA, namely the security proof for the weaker public ratchet used in the DR. In Appendix C we detail the constructions, from the proper CKA and FS-AEAD notions, of protocols DR (Double Ratchet) and TR (Triple Ratchet), which use essentially the same presentation as ACD (fixing their error as described in $T_{1}(\mathrm{DR})$ and modelling the KDF as a random oracle). We also formally demonstrate the weakness of the DR with respect to our stronger functionality $\mathcal{F}_{\mathrm{TR}}$. In Appendix D we provide the full technical details of our transformations to the DR, their insecurity with respect to our functionality $\mathcal{F}_{\mathrm{DR}}$, and their security with respect to ACD's and/or $\mathrm{CCD}^{+}$'s notion. In Appendix E we provide the security analyses of the Double Ratchet DR and Triple Ratchet TR, formalized in Theorem 5, which are essentially the same as that presented by ACD (but also using standard non-malleability arguments and programming the random oracle to handle corruptions with messages in-transit; again, see Appendix B.1). In Appendix F, we show how the techniques used in the TR can also be used to reduce the communication costs of practical UPKE schemes. Finally, Appendix G
contains technical descriptions of the UC framework, mostly borrowed from the literature, but adapted to our setting.

## 2 Defining Security of the Double Ratchet

In this section, we focus on obtaining an ideal functionality $\mathcal{F}_{\mathrm{DR}}$ that captures, as completely as possible, the security provided by the Double Ratchet algorithm. We emphasize that we study the security provided by the strongest implementation of the DR of which we are aware. For more on this, see Appendix D. We also provide an ideal functionality $\mathcal{F}_{\mathrm{TR}}$ that captures the security of our stronger TR protocol. Both functionalities are provided in Fig. 2.

$$
\mathcal{F}_{\mathrm{DR}} \text { and }\left\lceil\mathcal{F}_{\mathrm{TR}}\right\rfloor
$$

Notation: The ideal functionality interacts with two parties $\mathrm{P}_{1}, \mathrm{P}_{2}$, and an ideal adversary $\mathcal{S}$. The ideal functionality initializes lists of used message-ids $\mathrm{P}_{1} . \mathrm{M}$, intransit messages $\mathrm{P}_{1} . \mathrm{T}$ adversarially injected message-ids $\mathrm{P}_{1}$.I,
and vulnerable messages $\mathrm{P}_{1} \cdot \mathrm{~V}$ isent by $\mathrm{P}_{1}$ to $\mathrm{P}_{2}$ to $\phi$. Analogously, lists $\mathrm{P}_{2} . \mathrm{M}, \mathrm{P}_{2} . \mathrm{T}$,
![](https://cdn.mathpix.com/cropped/2025_02_24_f19b2c18609a278e5fd2g-13.jpg?height=31&width=458&top_left_y=924&top_left_x=164)
$P_{2}$ I and $P_{2}, V$ are also initialized to $\phi$. The ideal functionality also initializes leakage flags of both $P_{1}$ and $P_{2}$ for their corresponding (i) public ratchet secrets: $P_{1}$.PLEK, $\mathrm{P}_{2}$.PLEK, (ii) current sending epoch symmetric secrets: $\mathrm{P}_{1}$.CUR_SLEK, $P_{2}$.CUR_SLEK, and (iii) previous sending epoch symmetric secrets: $P_{1}$.PREV_SLEK, $P_{2}$.PREV_SLEK, all to 0 . Further, it initializes bad-randomness flags $P_{1}$.BAD, $P_{2}$.BAD and takeover possible flags $P_{1}$.TAKEOVER_POSS, $P_{2}$.TAKEOVER_POSS to 0 . Finally, it initializes the turn flag TURN as $\perp$.

- On input (sid, SETUP) from $P$ where $P \in\left\{P_{1}, P_{2}\right\}$ : Send (sid, SETUP, $P$ ) to $\mathcal{S}$. When $\mathcal{S}$ returns (sid, SETUP) then set TURN $\leftarrow \mathrm{P}$, and send (sid, INITIATED) to both $P_{1}$ and $P_{2}$. Ignore all future messages until this step is completed for sid. Once this happens $P$ can send the first message.
- On input (sid, mid, SEND, $m$ ) from $P \in\left\{P_{1}, P_{2}\right\}$ :

1. Ignore if mid $\in P . M$.
2. If $\bar{P} . C U R \_S L E K V(P . V \neq \emptyset)$ then $P . V \cup\{($ sid, mid,$m)\}$
![](https://cdn.mathpix.com/cropped/2025_02_24_f19b2c18609a278e5fd2g-13.jpg?height=52&width=1074&top_left_y=1519&top_left_x=240) $\bar{P} . C U R \_S L E K \wedge(P . P L E K \vee \bar{P} . P L E K)$, and (iii) $\bar{P} . T A K E O V E R \_P O S S ~ \leftarrow P . C U R \_S L E K$.
3. Add mid to P.M; if mid $\notin$ P. I then add (sid, mid, IN_TRANSIT, $m$, P.CUR_SLEK , TURN) to P.T; and pass (sid, mid, IN_TRANSIT, P, $|m|, m^{\prime}$ ) to $\mathcal{S}$ where $m^{\prime} \leftarrow$ $m$ if P.CUR_SLEK and $\perp$ otherwise.

- On input (sid, mid, DELIVER, $\mathrm{P}, m^{\prime}$ ) from $\mathcal{S}$ where $\mathrm{P} \in\left\{\mathrm{P}_{1}, \mathrm{P}_{2}\right\}$ :

1. Find (sid, mid, In_TRANSIT, $m, \beta, \gamma$ ) $\in$ P.T and remove it from P.T. Skip rest of the steps if no such entry is found.
2. If $\gamma=\mathrm{P}$ then set (i) TURN $\leftarrow \overline{\mathrm{P}}$, (ii) P.T $\leftarrow \operatorname{Flip}(\mathrm{P}, \mathrm{P} . \mathrm{T}),{ }^{b}$ (iii) P.PREV_SLEK $\leftarrow 0$, (iv) P.PREV_SLEK $\leftarrow \overline{\text { P. CUR_SLEK, (v) P. CUR_SLEK } \leftarrow 0 \text {, }}$ (vi) $\bar{P}$. PLEK $\leftarrow 0,($ vii) P.TAKEOVER POSS $\leftarrow 0,1$ and (viii) $\overline{\mathrm{P}} . \mathrm{V} \leftarrow \emptyset$.
3. If $\beta=1$ then set $m \leftarrow m^{\prime}$. Send (sid, mid, DELIVER, $m$ ) to $\overline{\mathrm{P}}$.

- On input (sid, LEAK, P ) from $\mathcal{S}$ where $\mathrm{P} \in\left\{\mathrm{P}_{1}, \mathrm{P}_{2}\right\}$ :

1. If $\neg \operatorname{New}(\mathrm{P}$, TURN, P.T) then set P.CUR_SLEK $\leftarrow 1$, P.PLEK $\leftarrow 1$, and $\overline{\mathrm{P}} . \mathrm{TAKEOVER} \mathrm{\_POSS} \leftarrow 1$.
2. If $\neg \operatorname{New}(\overline{\mathrm{P}}, \mathrm{TURN}, \overline{\mathrm{P}} . \mathrm{T})$ then set $\overline{\mathrm{P}}$.CUR_SLEK $\leftarrow 1$.
3. If TURN $=\overline{\mathrm{P}}$ then set $\overline{\mathrm{P}}$.PREV_SLEK $\leftarrow 1$.
4. If $\operatorname{New}(\mathrm{P}, \mathrm{TURN}, \mathrm{P} . \mathrm{T}) \vee(\neg \operatorname{New}(\overline{\mathrm{P}}$, TURN,$\overline{\mathrm{P}} . \mathrm{T}) \wedge \mathrm{TURN}=\overline{\mathrm{P}})$ then set P.TAKEOVER_POSS $\leftarrow 1$.
![](https://cdn.mathpix.com/cropped/2025_02_24_f19b2c18609a278e5fd2g-14.jpg?height=66&width=1067&top_left_y=396&top_left_x=289) $\bar{P} . T:-\overline{\text { and }} \bar{P} . \bar{V}$ to $\mathcal{S}$.

- On input $\overline{\text { (sid }}$, BAD_RANDOMNESS, $\mathrm{P}, \rho$ ) from $\mathcal{S}$ where $\rho \in\{0,1\}$ and $\mathrm{P} \in$ $\left\{\mathrm{P}_{1}, \mathrm{P}_{2}\right\}$ : Set $\mathrm{P} . \mathrm{BAD} \leftarrow \rho$.
- On input (sid, mid, INJECT, $\mathrm{P}, m, \delta, \gamma$ ) from $\mathcal{S}$ :

1. Skip if (mid $\in$ P.IUP.M) $\vee \neg\left(P . T A K E O V E R \_P O S S \vee P . P R E V \_S L E K \vee P . C U R \_S L E K\right)$.
2. If P.TAKEOVER_POSS $\wedge \delta$ then forward all subsequent incoming messages from $\overline{\mathrm{P}}$ to $\mathcal{S}$ and from $\mathcal{S}$ for $\overline{\mathrm{P}}$ directly to $\overline{\mathrm{P}}$. Also, remove from $\mathrm{P} . \mathrm{T}$ all elements of the form $(\cdot, \cdot$, IN_TRANSIT, $\cdot, \cdot, \mathrm{P})$ and drop all subsequent incoming messages for $\bar{P}$ generated by the ideal functionality (i.e., do not send them to $\overline{\mathrm{P}}$ ), except the ones generated according to the DELIVER command.
3. Otherwise, add mid to P.I and add to P.T (i) if TURN $=\overline{\mathrm{P}} \vee \neg$ P.CUR_SLEK then (sid, mid, IN_TRANSIT, $m, 1, \perp$ ), (ii) if TURN $=\mathrm{P} \wedge \neg \mathrm{P} . \mathrm{PREV}$ _SLEK then (sid, mid, IN_TRANSIT, $m, 1, \mathrm{P}$ ), and (iii) else (sid, mid, IN_TRANSIT, $m, 1, \gamma$ ).
```
${ }^{a} \operatorname{New}(\mathrm{P}$, TURN, P.T) outputs 1 if we have TURN $=\mathrm{P}$ and for all
    (sid, mid, IN_TRANSIT, $m, \beta, \gamma) \in \mathrm{P} . \mathrm{T}$ we have $\gamma \neq \mathrm{P}$; otherwise output 0 .
${ }^{b}$ Flip ( $\mathrm{P}, \mathrm{P} . \mathrm{T}$ ) for each (sid, mid, IN_TRANSIT, $\left.m, \beta, \mathrm{P}\right) \in \mathrm{P} . \mathrm{T}$ replaces it with
    (sid, mid, IN_TRANSIT, $m, \beta, \perp$ ).
${ }^{c}$ Unsafe(P.T) for each (sid, mid, In_TRANSIT, $m, \beta, \gamma$ ) $\in$ P.T replaces it with
    (sid, mid, IN_TRANSIT, $m, 1, \gamma$ ).
${ }^{d}$ Unsafe' ${ }^{\prime}$ P.T, P.V) for each (sid, mid, $m$ ) $\in$ P.V, if there is a cor-
    responding (sid, mid, IN_TRANSIT, $m, \beta, \gamma) \in$ P.T, replaces it with
    (sid, mid, IN_TRANSIT, $m, 1, \gamma$ ).
```

Fig. 2. The ideal functionalities $\mathcal{F}_{\mathrm{DR}}$ and $\mathcal{F}_{\mathrm{TR}}$, respectively.

### 2.1 Honest Execution

We start with a simplified view of the functionality where only the first three commands, namely SETUP, SEND, and DELIVER are executed. In other words, we consider a restricted view of the ideal functionality where leakage, bad randomness and injection attacks are not allowed. The adversary is still allowed to delay, reorder, and drop messages at will.

SETUP Command. This command can be initiated by either $\mathrm{P}=\mathrm{P}_{1}$ or $\mathrm{P}=$ $P_{2}$, and allows for initializing the communication channel between $P$ and $\bar{P}$. Looking ahead, in the real-world protocol, this initialization will involve sharing cryptographic secrets between the real-world P and real-world $\overline{\mathrm{P}}$, then properly initializing their states using these secrets. While the actual Signal protocol
uses the X3DH key exchange [41] for this, the focus of our work is to analyze the security and functionality of the double ratchet algorithm, and not X3DH. Therefore, we present a simple description for the SETUP command, that may be stronger than what X3DH achieves, but nonetheless suffices for our purposes.

We note that both $P_{1}$ and $P_{2}$ must receive (sid, INITIATED) before the communication between them can proceed. Turn status flag TURN is set to the initiator P to denote that P will be the first party to send a message.

SEND Command. This command allows $\mathrm{P} \in\left\{\mathrm{P}_{1}, \mathrm{P}_{2}\right\}$ to send a message $m$, under a unique assigned message id mid, to $\overline{\mathrm{P}}$. Naturally, the ideal functionality only allows P to send one message under each such mid, which it ensures by aborting in Step 1 if mid is already in list P.M, and subsequently adding mid to P.M in Step 4 otherwise. Now, this message might be dropped or delayed while in transit. Thus, at this point, the message is only added to the in-transit list P.T (Step 4) and the ideal-functionality waits for the instruction from the ideal-world adversary on when this message is to be delivered (if at all).

Observe that the last element of each tuple in P.T is TURN: the turn status when P attempted to send this message (i.e., when it was added to P.T). Looking ahead, this element is used in helper function $\operatorname{New}(P$, TURN, P.T) within SEND (Step 3) to determine whether $P$ is initiating a new epoch when sending a message and, if so, the (in)security of the new epoch. When discussing the DELIVER command below, we will explain the role the last element of P.T plays in the logic of $\operatorname{New}(P$, TURN, P.T) and further understand its role elsewhere in the functionality.

Finally, as typical with encryption, in the real-world the length of the encrypted message is often leaked by the ciphertext. Thus, the ideal functionality leaks the length of sent messages to the ideal adversary.

DELIVER Command. This command allows the ideal adversary to instruct the ideal functionality that a certain message, with unique message id mid, is no longer in-transit, and must be delivered to the recipient immediately, whether or not previously sent messages have already been delivered (thus transformation $T_{6}(\mathrm{DR})$ cannot realize the ideal functionality). The ideal functionality restricts the ideal adversary to delivering the message associated with this mid only once, which reflects the forward security of the DR - once a message is delivered, the recipient should no longer be able to decrypt it (in case she is leaked on afterwards). This is done by removing the entry for mid from P.T when it is delivered, so that subsequent deliveries cannot occur (Step 1).

As part of the delivery process (Step 2), the ideal functionality also checks if TURN was set to P when this message was sent. If so, the message was indeed the first of P's newest epoch that is delivered to $\overline{\mathrm{P}}$ (out of possibly many messages that can be the first delivered in the epoch). Thus, subsequently, it will next be $\bar{P}$ 's turn to start a new epoch. So, if this is the case, then TURN is flipped to $\bar{P}$. Additionally, helper function Flip(P, P.T) flips the last entry of each message from $P$ to $\bar{P}$ in P.T to $\perp$. This is done so that subsequently, when $P$ starts its next sending epoch, $\operatorname{New}(\mathrm{P}$, TURN, P.T) will return 1: TURN will flip back to P once
a message of $\bar{P}$ 's next sending epoch is delivered to $P$ for the first time, and there will be no element in P.T whose last entry is $P$. (Note: before $P$ receives a message for $\bar{P}$ 's next sending epoch, $P$ 's sent messages will not start a new epoch, as captured by $\operatorname{New}(\mathrm{P}$, TURN, $\mathrm{P} . \mathrm{T})$, since TURN will be set to $\overline{\mathrm{P}}$.)

We also note that since UC modelling typically allows the adversary to control the communication network [14] (and thus decide when ciphertexts should be delivered), there are some useless protocols that may realize $\mathcal{F}_{\mathrm{DR}}$ and $\mathcal{F}_{\mathrm{TR}}$. We define useless protocols as those in which with any PPT environment and adversary, parties do not generate output (i.e., not even a special reject symbol, like $\perp$, representing failed authentication) for at least one ciphertext delivery, with non-negligible probability. However, we can trivially rule out such useless protocols, so that all protocols that do realize $\mathcal{F}_{\mathrm{DR}}$ or $\mathcal{F}_{\mathrm{TR}}$ and that are not useless indeed generate the correct output immediately upon every delivery of a ciphertext from the adversary, with all-but-negligible probability.

### 2.2 Execution with an Unrestricted Adversary

In addition to delaying, reordering, and dropping messages, we assume that the real-world adversary can: (i) provide bad randomness for both parties, (ii) leak their secret states; possibly multiple times at various points in the execution, (iii) tamper with in-transit messages between the parties, and (iv) attempt to inject messages on behalf of both parties. Here, we explain how the ideal functionality captures this behavior.

The Ideal Functionality's Flags. The ideal functionality uses several binary flags to properly capture adversarial behavior. The functionality initializes all of them to 0 . Binary flag P.BAD captures bad randomness for party $P \in\left\{P_{1}, P_{2}\right\}$. Naturally, P.BAD is set to 0 or 1 when the ideal-world adversary issues a (sid, $\left.c m d B A D \_R A N D O M N E S S, \mathrm{P}, \rho\right)$ command to the ideal functionality, depending on the value of $\rho$. If P.BAD is set to 1 then P is provided with bad randomness (by the adversary, c.f. Appendix G) when she tries to sample some (thus rendering transformation $T_{5}(\mathrm{DR})$ insecure). Otherwise, P samples fresh randomness.

The ideal functionality further utilizes the following binary flags for each party $P \in\left\{P_{1}, P_{2}\right\}$ to capture the rest of the possible adversarial behavior. We first introduce their real-world semantic meaning here before explaining (i) their evolution within the ideal functionality as a result of the ideal world adversary's behavior, then (ii) how they thus allow the ideal functionality to determine security for the session.

- P.PLEK (Public Ratchet Secrets Leakage): If P.PLEK is set to 1 then P's public ratchet secrets are leaked to the real-world adversary. Otherwise, they should be hidden from the real-world adversary.
- P.CUR_SLEK (Current Sending Symmetric Ratchet Secrets Leakage): If P.CUR_SLEK is set to 1 then the symmetric ratchet secrets of P's current sending epoch are leaked to the real-world adversary. Otherwise, they should be hidden from the real-world adversary
- P.PREV_SLEK (Previous Sending Symmetric Ratchet Secrets Leakage): If P.PREV_SLEK is set to 1 then the symmetric ratchet secrets of the previous sending epoch of P are leaked to the real-world adversary. Otherwise, they should be hidden from the real-world adversary.
- P.TAKEOVER_POSS (Takeover Possible): If P.TAKEOVER_POSS is set to 1 then the real-world adversary has the option to take over the role of $P$ in the conversation with $\overline{\mathrm{P}}$. Otherwise, the real-world adversary should not have this option.

How the Flags are Affected by Leakages. We first describe how a leakage on one of the parties $\mathrm{P} \in\left\{\mathrm{P}_{1}, \mathrm{P}_{2}\right\}$ affects the above flags. For P.PLEK, when $\operatorname{New}(\mathrm{P}$, TURN, P.T $)=1$, it is P's turn to start her next sending epoch, but she has not yet started it. Thus she does not currently have any public ratchet secret state (just $\bar{P}$ 's public value), so there is no effect on P.PLEK if leakage on $P$ occurs in this case. If $\operatorname{New}(P, T U R N, P . T)=0$ when leakage on $P$ occurs, $P$ of course does have a public ratchet secret state, as she needs to be able to receive a message for $\overline{\mathrm{P}}$ 's next sending turn; thus in command LEAK, the ideal functionality sets P.PLEK to 1 (Step 1). Since P never stores $\overline{\text { P's }}$ public ratchet secrets, there is never any effect on $\bar{P}$.PLEK when P's state is leaked.

For P.CUR_SLEK, the functionality has similar behavior. If $\operatorname{New}(P, T U R N, ~ P . T)=$ 1 when leakage on $P$ occurs, $P$ has not yet generated the secrets for her next sending epoch, so P.CUR_SLEK is not modified. Otherwise, P has started the epoch, and so she stores the corresponding secrets in order to send new messages for the epoch; thus in command LEAK, we set P.CUR_SLEK to 1 (Step 1). Additionally, if $\operatorname{New}(\overline{\mathrm{P}}$, TURN,$\overline{\mathrm{P}} . \mathrm{T})=1$ then $\overline{\mathrm{P}}$ has not yet generated the secrets for her next sending epoch, so $\bar{P}$.CUR_SLEK is not modified. Otherwise, $\bar{P}$ has indeed started the epoch, in which case P must be able to derive the epoch's symmetric secrets (possibly using in-transit messages, which the adversary has), and thus in command LEAK we set $\bar{P}$.CUR_SLEK to 1 (Step 2).

For P.PREV_SLEK, since in the most secure version of the DR, P only ever stores the secrets for her current sending epoch (if she has indeed started it), leakage on P has no effect on P.PREV_SLEK. However, once it is $\overline{\mathrm{P}}$ 's turn to start a new sending epoch, $P$ still stores the secrets of $\bar{P}$ 's previous sending epoch (in case she needs to receive messages for it; she does not yet know $\overline{\mathrm{P}}$ will never again send a message for that epoch), until she receives a message in $\overline{\mathrm{P}}$ 's new epoch for the first time. Therefore, if TURN $=\overline{\mathrm{P}}$ then in command LEAK, we set $\bar{P}$. PREV_SLEK to 1 (Step 3); otherwise, if TURN $=P, \bar{P} . P R E V \_S L E K$ is not modified.

Finally, for P.TAKEOVER_POSS, if it is P's turn to start a new sending epoch, then of course a leakage on $P$ will enable the adversary to forge the first message of this new epoch and thus influence the subsequent state of $\overline{\mathrm{P}}$ upon delivery such that the adversary can take over P's role in the conversation (if it wishes). This is because the adversary will obtain the double ratchet root key, and can thus send such a message herself. Also, note that this key is derived from (i) P's previous state before she received any message for $\overline{\mathrm{P}}$ 's newest epoch and (ii) any message of $\overline{\mathrm{P}}$ 's newest sending epoch. Thus, additionally, if P is leaked while any message from $\overline{\mathrm{P}}$ 's newest epoch is in-transit, but before P receives any
such message, then the adversary can obtain the root key as above, and so will have the ability to forge the first message of $P$ 's next sending epoch. Therefore, in command LEAK, if $\operatorname{New}(\mathrm{P}$, TURN, $\mathrm{P} . \mathrm{T})=1$, or $\operatorname{New}(\overline{\mathrm{P}}$, TURN, $\overline{\mathrm{P}} . \mathrm{T})=0$ and TURN $=\overline{\mathrm{P}}$, then we set P.TAKEOVER_POSS to 1 (Step 4). Otherwise, if P has already sent the first message of the epoch, and $\bar{P}$ has not yet started her next sending epoch, leakage on P does not reveal the root key, so P.TAKEOVER_POSS is not modified. In the former case, this is because $P$ deletes the key after sending the message, and in the latter case, this is because the key does not yet exist. Furthermore, if P has indeed sent a message for her current sending epoch, then a leakage on $P$ will provide the adversary with the new root key. The adversary will therefore be able to forge the first message for $\overline{\mathrm{P}}$ 's next sending epoch. So, if $\operatorname{New}(\mathrm{P}$, TURN, $\mathrm{P} . \mathrm{T})=0$ then in command LEAK, we additionally set $\overline{\mathrm{P}}$.TAKEOVER_POSS to 1 (Step 1). Otherwise, if it is P's turn to start a new epoch, and she has not yet started it, then the new root key has not yet been generated, so $\bar{P}$.TAKEOVER_POSS is not modified.

How the Flags are Affected by Epoch Initialization. The effects on the ideal functionality's flags of epoch initialization via a SEND command are determined in Step 3 of the command. First, if P.BAD $=1$ when starting a new epoch (i.e. P uses bad randomness to start it), then we of course set P.PLEK to 1 (In the TR we may still here have security of P's public ratchet secret state, but we choose to capture slightly weaker security for simplicity); otherwise we set P.PLEK to 0 . Now, consider the privacy of the root key when $\overline{\mathrm{P}}$.CUR_SLEK is 1 and P is initializing a new epoch:

- If $\bar{P}$.CUR_SLEK was set to 1 when $\bar{P}$ initialized her newest epoch (as we explain below), then the root key must have been leaked in addition to the corresponding symmetric ratchet secrets, since they are both part of the same KDF output.
- If $\bar{P}$.CUR_SLEK was set to 1 as a result of a leakage on $P$, then the root key must have been also leaked, since $P$ needs it to start her new sending epoch.
- Finally, if $\bar{P}$.CUR_SLEK was set to 1 as a result of a leakage on $\bar{P}$, then the root key must have been also leaked, since $\overline{\mathrm{P}}$ needs it to receive a message for P's new sending epoch.

So, if $\bar{P}$.CUR_SLEK is 1 when $P$ initializes her new sending epoch, then it must be that the root key is leaked. Thus, only if $P$ and $\bar{P}$ have a secure key exchange can security for the DR be recovered, which only happens if both P.PLEK and P.PLEK are 0 , i.e., their public ratchet secrets are both hidden from the adversary. In this case, we set P.CUR_SLEK to 0 ; otherwise, we set it to 1 . If $\bar{P}$.CUR_SLEK is 0 at the time of initialization, then the root key must be hidden. This is because if not, then the current symmetric ratchet secrets of $\bar{P}$ would also not be hidden, since they were part of the same KDF output when $\overline{\mathrm{P}}$ started her latest sending epoch, and there were no subsequent leakages on either party. So we set P.CUR_SLEK to 0 upon initialization, in this case.

Finally, if we do indeed set P.CUR_SLEK to 1 at this time, as we noted above, this means that the new root key is known by the adversary, and thus
the adversary could forge the first message for $\overline{\mathrm{P}}$ 's next turn; otherwise the root key is hidden, and so the adversary does not have this ability. So, we set $\bar{P} . T A K E O V E R \_P O S S \leftarrow P . C U R \_S L E K$.

How the Flags are Affected by Epoch Termination. When the ideal adversary issues a DELIVER command for the first message of P's newest sending epoch, the ideal functionality needs to properly evolve the flags it uses to capture adversarial behavior (Step 2). First, when such a delivery occurs, $\overline{\mathrm{P}}$ 's latest sending epoch terminates, as her next message will be sent in a new epoch. To reflect this, upon such a delivery, the ideal functionality sets $\bar{P}$.PREV_SLEK $\leftarrow \bar{P}$.CUR_SLEK. Also, since $\overline{\mathrm{P}}$ deletes her public ratchet secrets upon reception of such a message, and her newest epoch has not actually started at this point, the functionality sets $\bar{P} . C U R \_S L E K ~ \leftarrow 0$ and $\bar{P}$.PLEK $\leftarrow 0$.

Furthermore, in the DR, $P$ includes in each message of an epoch the number of messages she sent in her previous epoch (see Appendix C). Thus, once $\bar{P}$ receives such a message in the DR , she knows exactly how many messages P sent in her previous epoch. So, the adversary can no longer inject messages in P's previous epoch (just modify them) and there is no more adversarial action possible for that epoch, so the functionality sets P.PREV_SLEK $\leftarrow 0$. Finally, since a message for P's newest sending epoch has indeed been delivered at this point, the secrets needed to start her next sending epoch are yet to be determined. Thus, the adversary cannot yet forge a message to start her next sending epoch, so the functionality sets P.TAKEOVER_POSS $\leftarrow 0$.

Determining New Messages' Privacy and Authenticity. We know from above that if P.CUR_SLEK $=1$, then P's current symmetric ratchet secrets are leaked to the adversary. Thus, if $P$ issues a SEND command for message $m$ with id mid, and P.CUR_SLEK $=1$, then the ideal functionality leaks the corresponding message to the ideal adversary (Step 4). Additionally, the ideal functionality sets the penultimate element of mid's entry in P.T to 1 . This will allow the ideal adversary to modify the message associated with mid upon delivery: the adversary will issue a DELIVER command for mid to the functionality with input modified message $m^{\prime}$, which will then be delivered $\overline{\mathrm{P}}$, instead of $m$ (Step 3).

Otherwise, if P.CUR_SLEK $=0$ when P issues the SEND command, then the ideal functionality only leaks the message length to the adversary and sets the penultimate element of the corresponding entry of P.T to 0 , ensuring (for now) privacy and authenticity of $m$.

The Consequences of Leakages. When the adversary leaks on P in the real-world, the privacy of in-transit messages from $\overline{\mathrm{P}}$ to P is no longer guaranteed, since P must preserve all keys that will be necessary for authenticating and decrypting them. Therefore, when the ideal adversary issues a LEAK command on $P$, the ideal functionality leaks the in-transit messages from $\overline{\mathrm{P}}$ to $\mathrm{P}, \mathrm{P} . \mathrm{T}$, to the ideal adversary, and allows the ideal adversary to modify them in the future (Step 5). The ideal functionality accomplishes the latter using helper function Unsafe ( $\bar{P} . T)$ which sets the penultimate element of each in-transit message of P.T to 1. As a
result, the ideal adversary can modify these in-transit messages in the DELIVER command, as described above. Note that only in-transit messages from $\overline{\mathrm{P}}$ to P are affected (thus rendering transformation $T_{2}(\mathrm{DR})$ insecure).
Vulnerable Messages in the DR. As explained in Sect.1.4, if in the DR, the root key is leaked when it is P's turn to start a new sending epoch, but $P$ has not yet started it, then the messages of that epoch are vulnerable. This means that if P is leaked on before $P$ receives a message of $\bar{P}$ 's next sending epoch for the first time, the messages that P sent in her own epoch become insecure.

To capture this, the ideal functionality in the SEND command adds messages to list P.V if they are indeed vulnerable (Step 2). At the start of the epoch, this is the case if $\bar{P}$. CUR_SLEK $=1$ (as explained above); in the middle of the epoch, this is the case if P.V is non-empty. Hence, if the adversary issues a LEAK command on P , in addition to the consequences of the above paragraph, the ideal functionality also leaks P.V and allows for future modification of its elements that are still intransit (Step 5). The latter is accomplished via helper function Unsafe'(P.T, P.V), similarly as in Unsafe $(\bar{P} . T)$. Note that this scenario, and the one above, are the only ones in which secure, in-transit messages are leaked to the adversary and/or subject to modification (thus transformation $T_{4}(\mathrm{DR})$ is insecure). Finally, if the adversary issues a DELIVER command for the first message of $\bar{P}$ 's next sending epoch, the ideal functionality sets $P . V=\emptyset: P$ properly deletes the secrets which make those messages vulnerable at this time.

Injections and Takeovers. If P.CUR_SLEK $=1$ or P.PREV_SLEK $=1$, then the adversary has the secrets required to inject its own messages into P's current or previous sending epoch, respectively. Also, if P.TAKEOVER_POSS $=1$, then the adversary can forge the first message to be delivered in P's next sending epoch to $\bar{P}$. In either case, the ideal adversary issues the INJECT command to inject message $m$ under unique message id mid on behalf of $P$. Of course, the ideal functionality only allows the adversary to inject one message under each such mid, which it ensures by aborting in Step 1 if mid is already in P.I, and adding it to P.I in Step 3 if not. The ideal functionality also aborts if a message with message id mid was already sent by P, i.e., it is in P.M, in which case injection of mid is not allowed, only modification. If the ideal adversary injects a message with id mid that is not a takeover forgery, then before actual delivery of the injection occurs, a corresponding entry is added to P.T.

Now, if P.TAKEOVER_POSS $=1$, and the ideal adversary inputs $\delta=1$ to the INJECT command, indicating that it wishes to takeover for P , then the ideal functionality thereafter directly forwards messages sent from P to the ideal adversary, and vice versa (Step 2).

If the ideal adversary injects a message with id mid that is not a takeover forgery, then before actual delivery of the injection occurs, a corresponding entry is added to P.T. However, the ideal functionality has to be careful to set the last element of this entry correctly:

- If TURN $=\overline{\mathrm{P}}$, then the first message of P 's current sending epoch has already been delivered to $\overline{\mathrm{P}}$. Thus, the last element of the entry is set to $\perp$, so that
if TURN is flipped to $P$, the entry's subsequent delivery does not prematurely flip TURN back. Moreover, if P.CUR_SLEK $=0$, then the adversary must be injecting into P's previous sending epoch, so for the same reason as above, we set its last entry to $\perp$.
- If P.PREV_SLEK $=0$ and TURN $=P$, then the adversary must be injecting into P's current sending epoch, and moreover, it might be that the injected message could be the first of the epoch delivered to $\bar{P}$. Therefore, we set TURN to P .
- If neither of the above are true, i.e., TURN $=P, P . P R E V \_S L E K ~=~ 1, ~ a n d ~$ P.CUR_SLEK $=1$, then it could be that the adversary is injecting into either P's previous or current sending epoch. Therefore, the ideal adversary specifies its choice of the last element with the last input $\gamma$ to the INJECT command.

Actual delivery of injections is then handled in the DELIVER command, in the same simple manner as specified in the Honest Execution Section (Sect. 2.1). Namely, delivery of injected message with message id mid is done by removing it from P.T (if such an entry exists), and sending it to $\bar{P}$. The functionality works this way in order to capture the scenario in which the real-world adversary modifies the first message of a new sending epoch for $P$ to inform $\bar{P}$ that $P$ 's last sending epoch contains more messages than it actually does. Therefore, the real-world adversary will be able to in the future inject such additional messages whenever it wants. The ideal-world adversary thus issues an INJECT command for all of these message ids at the time of the first modification, so that later it can actually send them to $\overline{\mathrm{P}}$ using DELIVER commands (regardless of the status of the functionality's flags at that time).

If an injected message with id mid is indeed added to P.T, then the ideal functionality needs to also make sure that $P$ can send a message with the same mid (since it does not know about the injection), but not allow the ideal adversary to deliver two messages with the same mid (since $\overline{\mathrm{P}}$ will only accept one such message in the DR). Therefore, in the SEND command, the ideal functionality checks if mid $\notin P$.I and if so adds the corresponding message to P.T as in the honest execution. However, if mid is in P.I, the ideal functionality does not add the corresponding message to P.T, but still sends the length of the message (and the message itself if P.CUR_SLEK $=1$ ) to the ideal adversary, mirroring that a ciphertext is still created in the real-world.

## 3 Continuous Key Agreement

In this section we formalize the main constructive contribution of our paper: the stronger, but virtually as efficient, public ratchet (and its mini ratchet) used by the Triple Ratchet protocol. More specifically, we first define (a version of) the continuous key agreement (CKA) primitive, introduced by ACD, which provides secrets for updates of the public ratchet. We provide two notions of security, that which is used by the DR and that which is used by the (stronger) TR. We also compare our definition to that of ACD. Then, we provide our CKA construction $\mathrm{CKA}^{+}$used in the TR and show it is secure according to the stronger definition,
via the strong- $D H$ (StDH) assumption [1] in the random oracle model. ${ }^{1}$ The StDH assumption is: given random and independent group elements $g^{a}, g^{b}$, and access to oracle $\operatorname{ddh}\left(g^{a}, \cdot, \cdot\right)$, which on input $X, Y$ returns 1 if $X^{a}=Y$ and 0 otherwise, it is hard to compute $g^{a b}$.

Defining CKA. At a high level, CKA is a synchronous two-party protocol between $P_{1}$ and $P_{2}$. Odd rounds $i$ consist of $P_{1}$ sending and $P_{2}$ receiving a message $T_{i}$, whereas in even rounds, $\mathrm{P}_{2}$ is the sender and $\mathrm{P}_{1}$ the receiver. Each round $i$ also produces a key $I_{i}$, which is output by the sender upon sending $T_{i}$ and by the receiver upon receiving $T_{i}$.

Definition 1. A continuous-key-agreement (CKA) scheme is a quadruple of algorithms $\mathrm{CKA}=\left(\mathrm{CKA}-\right.$ Init- $\mathrm{P}_{1}, \mathrm{CKA}-$ Init- $\left.\mathrm{P}_{2}, \mathrm{CKA}-\mathrm{S}, \mathrm{CKA}-\mathrm{R}\right)$, where

- CKA-Init- $\mathrm{P}_{1}$ (and similarly CKA-Init- $\mathrm{P}_{2}$ ) takes $a$ key $k$ and produces an initial state $\gamma^{\mathrm{P}_{1}} \leftarrow$ CKA-Init- $\mathrm{P}_{1}(k)\left(\right.$ and $\left.\gamma^{\mathrm{P}_{2}}\right)$,
- CKA-S takes a state $\gamma$, and produces a new state, message, and key $\left(\gamma^{\prime}, T, I\right) \stackrel{\$}{\rightleftarrows}$ CKA-S $(\gamma)$, and
- CKA-R takes a state $\gamma$ and message $T$ and produces new state and a key $\left(\gamma^{\prime}, I\right) \leftarrow \operatorname{CKA}-\mathrm{R}(\gamma, T)$.

Denote by $\mathcal{K}$ the space of initialization keys $k$ and by $\mathcal{I}$ the space of CKA keys $I$.

Correctness. A CKA scheme is correct if in the security game in Fig. 3 (explained below), $P_{1}$ and $P_{2}$ always, i.e., with probability 1, output the same key in every round.

Security. The security property we will require a CKA scheme to satisfy is that conditioned on the transcript $T_{1}, T_{2}, \ldots$, the keys $I_{1}, I_{2}, \ldots$ are unrecoverable. An attacker against a CKA scheme is required to be passive, i.e., may not modify the messages $T_{i}$. However, it is given the power to possibly (1) control the random coins used by the sender and (2) leak the current state of either party. Given the capabilities of the adversary, it is easy to see that some keys $I_{i}$ would be recoverable. The security guarantee offered by the CKA scheme would then be that even given the transcript $T_{1}, T_{2}, \ldots$, assuming certain "fine-grained" conditions around when the adversary controls the randomness used by parties and when the adversary learns the state of parties, most keys $I_{1}, I_{2}, \ldots$ are unrecoverable. It will also be the case that parties thus recover from such bad randomness and leakage issued by the adversary.

The formal security game for CKA is provided in Fig. 3. It begins with a call to the init oracle, which initializes the states of both parties, and defines
${ }^{1}$ We do not provide CKA schemes secure according to our definitions based on LWE or generic KEMs, as in ACD. However, we note that our stronger scheme CKA ${ }^{+}$ is intuitively at least as strong as their construction from generic KEMs, but more efficient.

## Security Games for CKA

$\operatorname{init}\left(t^{*}\right)$
$k \stackrel{\&}{\leftarrow} \mathcal{K}$
send- $P_{1}$
$t_{\mathrm{P}_{1}}++$
$\gamma_{0}^{\mathrm{P}_{1}} \leftarrow$
CKA-Init- $\mathrm{P}_{1}(k)$
$\gamma_{0}^{\mathrm{P}_{2}} \leftarrow$
CKA-Init- $\mathrm{P}_{2}(k)$
$t_{\mathrm{P}_{1}}, t_{\mathrm{P}_{2}} \leftarrow 0$
Recv-State $[*] \leftarrow \perp$
$\left(\gamma_{t_{\mathrm{P}_{1}}}^{\mathrm{P}_{1}}, T, I\right) \stackrel{\mathbb{\$}}{\leftarrow}$
ceive- ${ }_{1}$
$t_{\mathrm{P}_{1}}++$
$\left(\gamma_{t_{\mathrm{P}_{1}}}^{\mathrm{P}_{1}}, *\right) \leftarrow \operatorname{CKA}-\mathrm{R}\left(\gamma_{t_{\mathrm{P}_{1}}-1}^{\mathrm{P}_{1}}, T\right)$
CKA-S $\left(\gamma_{t_{P_{1}}}^{\mathrm{P}_{1}}\right)$
Recv-State $\left[t_{\mathrm{P}_{1}}+1\right] \leftarrow$
chall- $\mathbf{P}_{1}$
$t_{\mathrm{P}_{1}}++$
$\gamma_{t_{p_{1}}}^{p_{1}}$
return $(T, I)$
corr- $\mathrm{P}_{1}$
req allow-corr $\mathrm{P}_{1}$
return $\gamma_{t_{p_{1}}}^{p_{1}}$
send- $\mathbf{P}_{1}$ ' $(r)$
$t_{\mathrm{P}_{1}}++$
req allow-bad-rand $P_{1}$
$\left(\gamma_{t_{\mathrm{P}_{1}}}^{\mathrm{P}_{1}}, T, I\right) \leftarrow$
CKA-S $\left(\gamma_{t_{P_{1}-1}}^{\mathrm{P}_{1}} ; r\right)$
Recv-State $\left[t_{\mathrm{P}_{1}}+1\right] \leftarrow$
$\gamma_{t_{p_{1}}}^{\mathrm{P}_{1}}$
return $(T, I)$
req $t_{\mathrm{P}_{1}}=t^{*}$
$\left(\gamma_{t_{\mathrm{P}_{1}}}^{\mathrm{P}_{1}}, T, I\right) \stackrel{\Phi}{\leftarrow}$ CKA-S $\left(\gamma_{t_{\mathrm{P}_{1}}-1}^{\mathrm{P}_{1}}\right)$
return $T$
test $(t, T, I)$
req Recv-State $[t] \neq \perp$
if $(*, I) \leftarrow$
CKA-R(Recv-State $[t], T)$
return 1
else
return 0
allow-corr $\mathrm{P}_{1}: \Longleftrightarrow t_{\mathrm{P}_{1}} \neq t^{*}-1 \vee t^{*}$ is odd
allow-bad-rand $\mathrm{P}_{1}: \Longleftrightarrow t_{\mathrm{P}_{1}} \neq t^{*} \vee t_{\mathrm{P}_{1}} \neq t^{*}-1$
allow-corr${ }_{P_{2}}: \Longleftrightarrow t_{\mathrm{P}_{2}} \neq t^{*}-1 \vee t^{*}$ is even
allow-bad-rand $\mathrm{P}_{2}: \Longleftrightarrow t_{\mathrm{P}_{2}} \neq t^{*} \vee t_{\mathrm{P}_{2}} \neq t^{*}-1$

Fig. 3. Oracles corresponding to party $P_{1}$ of the CKA security game for a scheme $C K A=\left(C K A-I n i t-P_{1}, C K A-I n i t-P_{2}, C K A-S, C K A-R\right)$; the oracles for $P_{2}$ are defined analogously. Conditions for the weaker security game, i.e., $\varepsilon$-security, are presented to the left of those for the stronger game, i.e., $(\varepsilon,+)$-security.
epoch counters $t_{\mathrm{P}_{1}}$ and $t_{\mathrm{P}_{2}}$. Procedure init takes a value $t^{*}$, which determines in which round the challenge oracle may be called; the task of the adversary will be to recover the key $I_{t^{*}}$ for that round.

Upon completion of the initialization procedure, the attacker gets to interact arbitrarily with the remaining oracles, as long as the calls are in a "ping-pong" order, i.e., a call to a send oracle for $\mathrm{P}_{1}$ is followed by a receive call for $\mathrm{P}_{2}$, then by a send oracle for $P_{2}$, etc. The attacker only gets to use the challenge oracle for epoch $t^{*}$. The attacker additionally has the capability of testing the consistency of $T_{t}$ and $I_{t}$ (i.e., whether the receiver in epoch $t$ would produce key $I_{t}$ on input message $T_{t}$ ).

The security game of ACD is parametrized by $\Delta_{\mathrm{CKA}}$, which stands for the number of epochs that need to pass after $t^{*}$ until the states do not contain secret information pertaining to the challenge. Once a party reaches epoch $t^{*}+\Delta_{\mathrm{CKA}}$, its state may be revealed to the attacker (via the corresponding corruption oracle). We avoid this and define two levels of security, the former weaker than the
latter. At the bottom of Fig. 3, the conditions allow-corrp and allow-bad-randp for the weaker version are presented to the left of those of the stronger version. We define two levels of security in order to capture a stronger, more fine-grained security guarantee for CKA which will be useful in providing stronger security guarantees for the DR and TR as a whole when one considers the composition of all its building blocks, CKA being one of them. In the former, bad randomness is not allowed in the epochs $t^{*}$ and $t^{*}-1$, and corruptions are not allowed in the epoch $t^{*}$ after invoking CKA-S (for the sender of epoch $t^{*}$ ) and before invoking CKA-R (for the receiver of epoch $t^{*}$ ). In the latter, which is used by the TR, bad randomness is not allowed in the epochs $t^{*}$ and $t^{*}-1$, and corruption of the receiver of epoch $t^{*}$ is not allowed before invoking CKA-R (for epoch $t^{*}$ ). There is no other difference between the two notions.

The game ends (not made explicit) once both states are revealed after the challenge phase. The attacker wins the game if it eventually outputs the correct secret key $I_{t^{*}}$ corresponding to the challenge message $T_{t^{*}}$. The advantage of an attacker $\mathcal{A}$ against a CKA scheme CKA is denoted by $\operatorname{Adv}{ }^{\text {CKA }}(\mathcal{A})$ and $\operatorname{Adv}{ }^{\text {CKA }^{+}}(\mathcal{A})$ for the weaker and stronger security guarantees, respectively. The attacker is parameterized by its running time $t$.

Definition 2. A CKA scheme CKA is $(t, \varepsilon)$-secure (resp. $(t, \varepsilon,+)$-secure) if for all t-attackers $\mathcal{A}$,

$$
\operatorname{Adv}^{\mathrm{CKA}}(\mathcal{A}) \leq \varepsilon\left(\operatorname{resp} . \operatorname{Adv}^{\mathrm{CKA}^{+}}(\mathcal{A}) \leq \varepsilon\right)
$$

Definition 3. $A$ CKA scheme CKA is simply called $\varepsilon$-secure (resp. ( $\varepsilon,+$ )secure) if for every $t \in \operatorname{poly}(\kappa)$ and $\varepsilon \in \operatorname{negl}(\kappa)$, where $\kappa$ is the security parameter,

$$
\operatorname{Adv}^{\mathrm{CKA}}(\mathcal{A}) \leq \varepsilon\left(\text { resp. } \operatorname{Adv}^{\mathrm{CKA}^{+}}(\mathcal{A}) \leq \varepsilon\right)
$$

Observe that since the TR uses a CKA with the latter, stronger security, the attack of Sect. 1.4 is thwarted. This is because even if the epoch $t^{*}$ sender is corrupted after invoking CKA-S, $I_{t^{*}}$ should remain hidden.

Remark 1. Many natural CKA schemes satisfy an additional property that given a CKA message $T$ and key $I$ for a given round, it is possible to deterministically compute the corresponding state of the receiving party after her execution of CKA-R in that round. We model this explicitly by requiring a deterministic algorithm CKA-Der-R that takes a message $T$ and key $I$ and produces the correct state $\gamma^{\prime} \leftarrow \operatorname{CKA}-\operatorname{Der}-\mathrm{R}(T, I)$. All CKA schemes in this work are required to be natural.

## Differences from ACD

Fine-Grained Security Guarantees. Recall the "CKA from DDH" scheme from ACD (which is the public ratchet used in the DR and which we prove security for in Appendix B.3), CKA $=\left(\right.$ CKA-Init-P ${ }_{1}$, CKA-Init- $P_{2}$, CKA-S, CKA-R $)$, that is instantiated in a cyclic group $G=\langle g\rangle$ as follows:

- The initial shared state $k=\left(h, x_{0}\right)$ consists of a (random) group element $h=g^{x_{0}}$ and its discrete logarithm $x_{0}$. The initialization for $\mathrm{P}_{1}$ outputs $h \leftarrow$ CKA-Init- $\mathrm{P}_{1}(k)$ and that for $\mathrm{P}_{2}$ outputs $x_{0} \leftarrow$ CKA-Init- $\mathrm{P}_{2}(k)$.
- The send algorithm CKA-S takes as input the current state $\gamma=h$ and proceeds as follows: It

1. chooses a random exponent $x$;
2. computes the corresponding key $I \leftarrow h^{x}$;
3. sets the CKA message to $T \leftarrow g^{x}$;
4. sets the new state to $\gamma \leftarrow x$; and
5. returns $(\gamma, T, I)$.

- The receive algorithm CKA-R takes as input the current state $\gamma=x$ as well as a message $T=h$ and proceeds as follows: It

1. computes the key $I=h^{x}$;
2. sets the new state to $\gamma \leftarrow h$; and
3. returns $(\gamma, I)$.

Now, let $x_{0}$ be the random exponent that is part of the initial shared state, and for $i>0$, let $x_{i}$ be the random exponent picked by CKA-S (which was run by $\mathrm{P}_{1}$ for odd $i$, and $\mathrm{P}_{2}$ for even $i$ ) in round $i$. Then, we have the following:

- The key for round $i$ is $I_{i}=g^{x_{i-1} x_{i}}$.
- The message for round $i$ is $T_{i}=g^{x_{i}}$.
- If $i$ is odd, and $\mathrm{P}_{1}$ has yet to invoke CKA-S, $\gamma^{\mathrm{P}_{1}}=g^{x_{i-1}}$ and $\gamma^{\mathrm{P}_{2}}=x_{i-1}$.
- If $i$ is odd, and $\mathrm{P}_{1}$ has invoked CKA-S, but $\mathrm{P}_{2}$ has yet to invoke CKA-R, $\gamma^{\mathrm{P}_{1}}=x_{i}$ and $\gamma^{\mathrm{P}_{2}}=x_{i-1}$.
- If $i$ is odd, and $\mathrm{P}_{1}$ has invoked CKA-S, and $\mathrm{P}_{2}$ has invoked CKA-R, $\gamma^{\mathrm{P}_{1}}=x_{i}$ and $\gamma^{\mathrm{P}_{2}}=g^{x_{i}}$.
- If $i$ is even, and $\mathrm{P}_{2}$ has yet to invoke CKA-S, $\gamma^{\mathrm{P}_{1}}=x_{i-1}$ and $\gamma^{\mathrm{P}_{2}}=g^{x_{i-1}}$.
- If $i$ is even, and $P_{2}$ has invoked CKA-S, but $P_{1}$ has yet to invoke CKA-R, $\gamma^{\mathrm{P}_{1}}=x_{i-1}$ and $\gamma^{\mathrm{P}_{2}}=x_{i}$.
- If $i$ is even, and $\mathrm{P}_{2}$ has invoked CKA-S, and $\mathrm{P}_{1}$ has invoked CKA-R, $\gamma^{\mathrm{P}_{1}}=g^{x_{i}}$ and $\gamma^{\mathrm{P}_{2}}=x_{i}$.

Based on the above, we make the following observations:

- If $i$ is odd and $\mathrm{P}_{1}$ is corrupted after invoking CKA-S, the adversary learns $\gamma^{\mathrm{P}_{1}}=x_{i}$ and since it also has access to $g^{x_{j}}$ for all $j \geq 1$, the adversary learns $I_{i}$ and $I_{i+1}$.
- If $i$ is even and $\mathrm{P}_{1}$ is corrupted after invoking CKA-R, and $\mathrm{P}_{2}$ used good randomness in picking $x_{i}$ while invoking CKA-S in round $i$, the adversary learns $\gamma^{\mathrm{P}_{1}}=g^{x_{i}}$, but since it only (assuming no other corruptions) has access to $g^{x_{j}}$ for all $j \geq 1$, the adversary does not learn $I_{i}$ (if $\mathrm{P}_{1}$ also used good randomness in picking $x_{i-1}$ while invoking CKA-S in round $i-1$ ) or $I_{i+1}$ (if $\mathrm{P}_{1}$ also uses good randomness in picking $x_{i+1}$ while invoking CKA-S in round $i+1)$.

Thus, the CKA keys for two rounds are compromised only in the case where the party that has last sent a message is corrupted, and not if the party has last received a message. This allows us to consider a more fine-grained version of the CKA security game than the one described in ACD.

Non-malleability. Consider the following scenario in the DR or TR: It is $\mathrm{P}_{1}$ 's turn to start a new sending epoch, but she has not yet. Then her state is leaked, and afterwards, she sends the first message $m_{1}$ of the epoch with good randomness. Then, if $P_{2}$ started her last epoch with good randomness, and there are no other leakages, $m_{1}$ is required to remain private by $\mathcal{F}_{\mathrm{DR}}$ and $\mathcal{F}_{\mathrm{TR}}$, respectively. However, all authenticity for $m_{1}$ is lost - the adversary leaked on $\mathrm{P}_{1}$ beforehand and thus could have generated the message herself. Therefore, we replace the indistinguishability definition of ACD with our recoverability definition and require non-malleability of CKA messages via the test oracle - the adversary should not be able to maul them in order to learn about the actual session messages sent in the DR or TR. Note that this modification makes our CKA definition incomparable in strength to that of ACD, but allows us to prove stronger security for the DR. See the full security proof of Theorem 5 for the DR and TR, as well as Appendix D.2, for more details.
Instantiating CKA $^{+}$. A CKA scheme CKA $^{+}=\left(\right.$CKA-Init- $P_{1}$, CKA-Init- $\mathrm{P}_{2}$, CKA-S, CKA-R) (which may be used in the TR) can be obtained assuming random oracles or circular-secure ElGamal in a cyclic group $G=\langle g\rangle$ (with exponent space $\mathcal{X}$ ) using a function $\mathrm{H}: \mathcal{I} \rightarrow \mathcal{X}$ as follows:

- The initial shared state $k=\left(h, x_{0}\right)$ consists of a (random) group element $h=g^{x_{0}}$ and its discrete logarithm $x_{0}$. The initialization for $\mathrm{P}_{1}$ outputs $h \leftarrow$ CKA-Init- $\mathrm{P}_{1}(k)$ and that for $\mathrm{P}_{2}$ outputs $x_{0} \leftarrow$ CKA-Init- $\mathrm{P}_{2}(k)$.
- The send algorithm CKA-S takes as input the current state $\gamma=h$ and proceeds as follows: It

1. chooses a random exponent $x$;
2. computes the corresponding key $I \leftarrow h^{x}$;
3. sets the CKA message to $T \leftarrow g^{x}$;
4. sets the new state to $\gamma \leftarrow x \cdot \mathrm{H}(I)$; and
5. returns $(\gamma, T, I)$.

- The receive algorithm CKA-R takes as input the current state $\gamma=x$ as well as a message $T=h$ and proceeds as follows: It

1. computes the key $I=h^{x}$;
2. sets the new state to $\gamma \leftarrow h^{\mathrm{H}(I)}$; and
3. returns $(\gamma, I)$.

Note that the above scheme is natural, i.e., it supports a CKA-Der-R algorithm, namely, CKA-Der- $\mathrm{R}(T, I)=T^{\mathrm{H}(I)}$. Now we show its security in the theorem below. (We give informal details on additional security properties that we conjecture it to have in Appendix B.3)

Theorem 1. Assume group $G$ is $(t, \varepsilon)$-StDH-secure. Additionally, assume the existence of a random oracle H . Then, the above CKA scheme CKA is $\left(t^{\prime}, \varepsilon,+\right)$ secure for $t \approx t^{\prime}$.

Proof. Assume w.l.o.g. that $t^{*}$ is odd, i.e., $\mathrm{P}_{1}$ sends the challenge; the case where $t^{*}$ is even is handled analogously. Let $g^{a}, g^{b}$ be a StDH challenge. The reduction simulates the CKA protocol in the straight-forward way but embeds the challenge into the CKA as follows:

- in epoch $t^{*}-1$, it uses $T_{t^{*}-1}=g^{a}$ and $I_{t^{*}-1}=g^{x a \mathrm{H}\left(I_{t^{*}-2}\right)}$, where $x$ is the exponent used to simulate $T_{t^{*}-2}=g^{x}$.
- in epoch $t^{*}$, it uses $T_{t^{*}}=g^{b}$ and $I_{t^{*}}=g^{a b \mathrm{H}\left(I_{t^{*}-1}\right)}$ which is the key the adversary is to recover, as well as sets $\gamma_{t^{*}}^{\mathrm{P}_{1}} \leftarrow y$, for random $y$ in $\mathcal{X}$;
- in epoch $t^{*}+1$, for exponent $x^{\prime}$ (possibly generated using adversarial randomness), it uses $T_{t^{*}+1}=g^{x^{\prime}}$ and $I_{t^{*}+1}=g^{y x^{\prime}}$.

It is easy to verify that this correctly simulates the CKA experiment since H is a random oracle. In particular, randomly sampled $y$ properly simulates $b \cdot \mathrm{H}\left(I_{t^{*}}\right)$ : If $\mathcal{A}$ does not query the random oracle on $I_{t^{*}}$ then $y$ is properly distributed. Moreover, when $\mathcal{A}$ makes a random oracle query for any $I$, the reduction can query oracle $\operatorname{ddh}\left(g^{a}, \cdot, \cdot\right)$ on $\left(g^{b \mathrm{H}\left(I_{t^{*}-1}\right)}, I\right)$ so that if indeed $I=I_{t^{*}}$, the reduction will know, and then forward to its challenger $g^{a b}=I_{t^{*}}^{1 / \mathrm{H}\left(I_{t^{*}-1}\right)}$ before answering the CKA ${ }^{+}$attacker's query.

Similarly, the test oracle can be perfectly simulated with the help of $\operatorname{ddh}()$ : if $\operatorname{test}\left(t^{*}, T, I\right)$ is queried, the reduction simply queries $\operatorname{ddh}\left(g^{a}, \cdot, \cdot\right)$ on $\left(T^{\mathrm{H}\left(I_{t^{*}-1}\right)}, I\right)$; all other test () queries can be directly simulated.

Acknowledgements. We would like to thank Yevgeniy Dodis and Daniel Jost for helping us realize that the trick used in the CKA ${ }^{+}$construction can also be used to make UPKE more efficient (Appendix F).

This research is supported in part by DARPA under Agreement No. HR00112020026, AFOSR Award FA9550-19-1-0200, NSF CNS Award 1936826, and research grants by the Sloan Foundation, and Visa Inc. Any opinions, findings and conclusions or recommendations expressed in this material are those of the author(s) and do not necessarily reflect the views of the United States Government or DARPA.

## References

1. Abdalla, M., Bellare, M., Rogaway, P.: The Oracle Diffie-Hellman assumptions and an analysis of DHIES. In: Naccache, D. (ed.) CT-RSA 2001. LNCS, vol. 2020, pp. 143-158. Springer, Heidelberg (2001). https://doi.org/10.1007/3-540-45353-9_12
2. Alwen, J., Coretti, S., Dodis, Y.: The double ratchet: security notions, proofs, and modularization for the Signal protocol. Cryptology ePrint Archive, Report 2018/1037 (2018). https://eprint.iacr.org/2018/1037
3. Alwen, J., Coretti, S., Dodis, Y.: The double ratchet: security notions, proofs, and modularization for the signal protocol. In: Ishai, Y., Rijmen, V. (eds.) EUROCRYPT 2019, Part I. LNCS, vol. 11476, pp. 129-158. Springer, Cham (2019). https://doi.org/10.1007/978-3-030-17653-2_5
4. Alwen, J., Coretti, S., Dodis, Y., Tselekounis, Y.: Security analysis and improvements for the IETF MLS standard for group messaging. In: Micciancio, D., Ristenpart, T. (eds.) CRYPTO 2020, Part I. LNCS, vol. 12170, pp. 248-277. Springer, Cham (2020). https://doi.org/10.1007/978-3-030-56784-2_9
5. Balli, F., Rsler, P., Vaudenay, S.: Determining the core primitive for optimally secure ratcheting. In: Moriai, S., Wang, H. (eds.) ASIACRYPT 2020, Part III. LNCS, vol. 12493, pp. 621-650. Springer, Cham (2020). https://doi.org/10.1007/ 978-3-030-64840-4_21
6. Bao, F., Deng, R.H., Zhu, H.: Variations of diffie-hellman problem. In: ICICS (2003)
7. Bellare, M., Singh, A.C., Jaeger, J., Nyayapati, M., Stepanovs, I.: Ratcheted encryption and key exchange: the security of messaging. In: Katz, J., Shacham, H. (eds.) CRYPTO 2017, Part III. LNCS, vol. 10403, pp. 619-650. Springer, Cham (2017). https://doi.org/10.1007/978-3-319-63697-9_21
8. Bienstock, A., Fairoze, J., Garg, S., Mukherjee, P., Srinivasan, R.: A more complete analysis of the signal double ratchet algorithm. Cryptology ePrint Archive, Report 2022/355 (2022)
9. Bitansky, N., Canetti, R., Halevi, S.: Leakage-tolerant interactive protocols. In: Cramer, R. (ed.) TCC 2012. LNCS, vol. 7194, pp. 266-284. Springer, Heidelberg (2012). https://doi.org/10.1007/978-3-642-28914-9_15
10. Borisov, N., Goldberg, I., Brewer, E.: Off-the-record communication, or, why not to use PGP. In: Proceedings of the 2004 ACM Workshop on Privacy in the Electronic Society, pp. 77-84 (2004)
11. Brendel, J., Fiedler, R., Gnther, F., Janson, C., Stebila, D.: Post-quantum asynchronous deniable key exchange and the signal handshake. In: Hanaoka, G., Shikata, J., Watanabe, Y. (eds.) Public-Key Cryptography - PKC 2022, pp. 334. Springer International Publishing, Cham (2022)
12. Brendel, J., Fischlin, M., Gnther, F., Janson, C.: PRF-ODH: relations, instantiations, and impossibility results. In: Katz, J., Shacham, H. (eds.) CRYPTO 2017, Part III. LNCS, vol. 10403, pp. 651-681. Springer, Cham (2017). https://doi.org/ 10.1007/978-3-319-63697-9_22
13. Brendel, J., Fischlin, M., Gnther, F., Janson, C., Stebila, D.: Towards postquantum security for signal's x3dh handshake. In: Selected Areas in CryptographySAC 2020 (2020)
14. Canetti, R.: Universally composable security: a new paradigm for cryptographic protocols. In: 42nd FOCS, pp. 136-145. IEEE Computer Society Press, Las Vegas, 14-17 October 2001
15. Canetti, R., Halevi, S., Katz, J.: Chosen-ciphertext security from identity-based encryption. In: Cachin, C., Camenisch, J.L. (eds.) EUROCRYPT 2004. LNCS, vol. 3027, pp. 207-222. Springer, Heidelberg (2004). https://doi.org/10.1007/978-3-540-24676-3_13
16. Canetti, R., Jain, P., Swanberg, M., Varia, M.: Universally composable end-to-end secure messaging. In: CRYPTO 2022 (2022)
17. Checkoway, S., et al.: On the practical exploitability of dual EC in TLS implementations. In: Fu, K., Jung, J. (eds.) USENIX Security 2014, pp. 319-335. USENIX Association, San Diego, CA, USA, 20-22 August 2014
18. Cohn-Gordon, K., Cremers, C., Dowling, B., Garratt, L., Stebila, D.: A formal security analysis of the signal messaging protocol. In: 2017 IEEE European Symposium on Security and Privacy, EuroS\&P 2017, Paris, France, April 26-28, 2017, pp. 451-466. IEEE (2017). https://doi.org/10.1109/EuroSP.2017.27
19. Cohn-Gordon, K., Cremers, C., Dowling, B., Garratt, L., Stebila, D.: A formal security analysis of the signal messaging protocol. J. Cryptol. 33(4), 1914-1983 (2020). https://doi.org/10.1007/s00145-020-09360-1
20. Cohn-Gordon, K., Cremers, C.J.F., Garratt, L.: On post-compromise security. In: Hicks, M., Kpf, B. (eds.) CSF 2016 Computer Security Foundations Symposium, pp. 164-178. IEEE Computer Society Press, Lisbon, Portugal, June 27-1 2016
21. Cramer, R., Shoup, V.: Design and analysis of practical public-key encryption schemes secure against adaptive chosen ciphertext attack. SIAM J. Comput. 33(1), 167-226 (2003)
22. Dobson, S., Galbraith, S.D.: Post-quantum signal key agreement with sidh. Cryptology ePrint Archive, Report 2021/1187 (2021)
23. Dodis, Y., Karthikeyan, H., Wichs, D.: Updatable public key encryption in the standard model (2021)
24. Durak, F.B., Vaudenay, S.: Breaking the FF3 format-preserving encryption standard over small domains. In: Katz, J., Shacham, H. (eds.) CRYPTO 2017, Part II. LNCS, vol. 10402, pp. 679-707. Springer, Cham (2017). https://doi.org/10.1007/ 978-3-319-63715-0_23
25. Durak, F.B., Vaudenay, S.: Bidirectional asynchronous ratcheted key agreement with linear complexity. In: Attrapadung, N., Yagi, T. (eds.) IWSEC 2019. LNCS, vol. 11689, pp. 343-362. Springer, Cham (2019). https://doi.org/10.1007/978-3-030-26834-3_20
26. FIPS, P.: 180-1. secure hash standard. National Institute of Standards and Technology 17, 45 (1995)
27. Galbraith, S.D.: Mathematics of Public Key Cryptography. Cambridge University Press, Cambridge (2012)
28. Goldreich, O.: The Foundations of Cryptography - Volume 2: Basic Applications. Cambridge University Press (2004). http://www.wisdom.weizmann.ac.il/ \%7Eoded/foc-vol2.html
29. Goldwasser, S., Micali, S., Rackoff, C.: The knowledge complexity of interactive proof systems. SIAM J. Comput. 18(1), 186-208 (1989). https://doi.org/10.1137/ 0218012
30. Hashimoto, K., Katsumata, S., Kwiatkowski, K., Prest, T.: An efficient and generic construction for signal's handshake (x3dh): post-quantum, state leakage secure, and deniable. In: Public Key Cryptography (2), pp. 410-440 (2021)
31. Heninger, N., Durumeric, Z., Wustrow, E., Halderman, J.A.: Mining your PS and QS: detection of widespread weak keys in network devices. In: Kohno, T. (ed.) USENIX Security 2012, pp. 205-220. USENIX Association, Bellevue, WA, USA, 8-10 August 2012
32. Jaeger, J., Stepanovs, I.: Optimal channel security against fine-grained state compromise: the safety of messaging. In: Shacham, H., Boldyreva, A. (eds.) CRYPTO 2018, Part I. LNCS, vol. 10991, pp. 33-62. Springer, Cham (2018). https://doi. org/10.1007/978-3-319-96884-1_2
33. Jost, D., Maurer, U.: Overcoming impossibility results in composable security using interval-wise guarantees. In: Micciancio, D., Ristenpart, T. (eds.) CRYPTO 2020, Part I. LNCS, vol. 12170, pp. 33-62. Springer, Cham (2020). https://doi.org/10. 1007/978-3-030-56784-2_2
34. Jost, D., Maurer, U., Mularczyk, M.: Efficient ratcheting: almost-optimal guarantees for secure messaging. In: Ishai, Y., Rijmen, V. (eds.) EUROCRYPT 2019. LNCS, vol. 11476, pp. 159-188. Springer, Cham (2019). https://doi.org/10.1007/ 978-3-030-17653-2_6
35. Jost, D., Maurer, U., Mularczyk, M.: A unified and composable take on ratcheting. In: Hofheinz, D., Rosen, A. (eds.) TCC 2019. LNCS, vol. 11892, pp. 180-210. Springer, Cham (2019). https://doi.org/10.1007/978-3-030-36033-7_7
36. Kiltz, E.: A Tool box of cryptographic functions related to the Diffie-Hellman function. In: Rangan, C.P., Ding, C. (eds.) INDOCRYPT 2001. LNCS, vol. 2247, pp. 339-349. Springer, Heidelberg (2001). https://doi.org/10.1007/3-540-453113_32
37. Kobeissi, N., Bhargavan, K., Blanchet, B.: Automated verification for secure messaging protocols and their implementations: A symbolic and computational approach. In: 2017 IEEE European Symposium on Security and Privacy (EuroS\&P), pp. 435-450 (2017)
38. Krawczyk, H., Eronen, P.: Hmac-based extract-and-expand key derivation function (hkdf). Technical report, RFC 5869, May 2010
39. Kurosawa, K., Matsuo, T.: How to remove MAC from DHIES. In: Wang, H., Pieprzyk, J., Varadharajan, V. (eds.) ACISP 2004. LNCS, vol. 3108, pp. 236-247. Springer, Heidelberg (2004). https://doi.org/10.1007/978-3-540-27800-9_21
40. Marlinspike, M., Perrin, T.: The Double Ratchet Algorithm (11 2016). https:// whispersystems.org/docs/specifications/doubleratchet/doubleratchet.pdf
41. Marlinspike, M., Perrin, T.: The X3DH Key Agreement Protocol (11 2016). https://signal.org/docs/specifications/x3dh/x3dh.pdf
42. Maurer, U.: Constructive cryptography - a new paradigm for security definitions and proofs. In: Mdersheim, S., Palamidessi, C. (eds.) TOSCA 2011. LNCS, vol. 6993, pp. 33-56. Springer, Heidelberg (2012). https://doi.org/10.1007/978-3-642-27375-9_3
43. Maurer, U.M., Wolf, S.: Diffie-Hellman Oracles. In: Koblitz, N. (ed.) CRYPTO 1996. LNCS, vol. 1109, pp. 268-282. Springer, Heidelberg (1996). https://doi.org/ 10.1007/3-540-68697-5_21
44. Nielsen, J.B.: Separating random Oracle proofs from complexity theoretic proofs: the non-committing encryption case. In: Yung, M. (ed.) CRYPTO 2002. LNCS, vol. 2442, pp. 111-126. Springer, Heidelberg (2002). https://doi.org/10.1007/3-540-45708-9_8
45. Poettering, B., Rsler, P.: Towards bidirectional ratcheted key exchange. In: Shacham, H., Boldyreva, A. (eds.) CRYPTO 2018. LNCS, vol. 10991, pp. 3-32. Springer, Cham (2018). https://doi.org/10.1007/978-3-319-96884-1_1
46. Shoup, V.: Lower bounds for discrete logarithms and related problems. In: Fumy, W. (ed.) EUROCRYPT 1997. LNCS, vol. 1233, pp. 256-266. Springer, Heidelberg (1997). https://doi.org/10.1007/3-540-69053-0_18
47. Sipser, M.: Introduction to the theory of computation. PWS Publishing Company (1997)
48. Unger, N., Goldberg, I.: Deniable key exchanges for secure messaging. In: Ray, I., Li, N., Kruegel, C. (eds.) ACM CCS 2015, pp. 1211-1223. ACM Press, Denver, CO, USA, 12-16 October 2015
49. Unger, N., Goldberg, I.: Improved strongly deniable authenticated key exchanges for secure messaging. Proc. Priv. Enhancing Technol. 2018(1), 21-66 (2018)
50. Vatandas, N., Gennaro, R., Ithurburn, B., Krawczyk, H.: On the cryptographic deniability of the signal protocol. In: Conti, M., Zhou, J., Casalicchio, E., Spognardi, A. (eds.) ACNS 2020. LNCS, vol. 12147, pp. 188-209. Springer, Cham (2020). https://doi.org/10.1007/978-3-030-57878-7_10
51. Yilek, S., Rescorla, E., Shacham, H., Enright, B., Savage, S.: When private keys are public: results from the 2008 debian openssl vulnerability. In: Proceedings of the 9 th ACM SIGCOMM Conference on Internet Measurement, IMC 2009, pp. 15-27. Association for Computing Machinery, New York (2009). https://doi.org/ 10.1145/1644893.1644896

[^0]:    Supplementary Information The online version contains supplementary material available at https://doi.org/10.1007/978-3-031-15802-5_27.

