```constants.ts
// === File: src/constants.ts ===

import { p256 } from "@noble/curves/p256"; // Needed for P256_ORDER

export const CURVE_NAME = "P-256"; // Still relevant for context, matches noble p256
export const HASH_ALGORITHM_NAME = "SHA-256"; // For Web Crypto hashData
export const HMAC_ALGORITHM = {
  name: "HMAC",
  hash: { name: "SHA-256" },
} as const; // For Web Crypto HKDF/HMACKey import
export const AES_ALGORITHM = { name: "AES-GCM", length: 256 } as const; // For Web Crypto AES
export const INFO_RATCHET = new TextEncoder().encode("TripleRatchetInfo");
export const MAX_SKIP = 100; // Maximum number of message keys to skip
export const P256_ORDER = p256.CURVE.n; // Order of the P-256 curve for modular arithmetic

```

```crypto\crypto-utils.ts
// === File: src/crypto/crypto-utils.ts ===

import { p256 } from "@noble/curves/p256";
import { sha256 } from "@noble/hashes/sha256";
// import { hmac } from '@noble/hashes/hmac'; // Only needed for manual HKDF
import { bytesToHex, hexToBytes } from "@noble/hashes/utils";
import { getCrypto } from "../utils/environment"; // Use relative path
import { concatBuffers, equalBuffers } from "../utils/buffer"; // Use relative path - Added equalBuffers import
import {
  AES_ALGORITHM,
  HMAC_ALGORITHM,
  HASH_ALGORITHM_NAME,
  INFO_RATCHET, // Needed for HKDF
} from "../constants"; // Use relative path
import type {
  // Use 'type' import for interfaces/types
  ECKeyPair,
  SigningKeyPair,
  ECDHPublicKey,
  ECDHPrivateKey,
  ECDSAPublicKey,
  ECDSAPrivateKey,
  SerializedECPublicKey, // This type uses hex string now
  HMACKey,
  AESKey,
} from "../types"; // Use relative path

/**
 * Generates a new ECDH key pair (P-256) using noble-curves.
 * @returns An ECKeyPair with keys as Uint8Array.
 */
export function generateECDHKeyPair(): ECKeyPair {
  const privateKey = p256.utils.randomPrivateKey();
  const publicKey = p256.getPublicKey(privateKey, false); // false = uncompressed format
  return {
    privateKey: privateKey, // 32 bytes scalar
    publicKey: publicKey, // 65 bytes (0x04 + x + y)
  };
}

/**
 * Generates a new ECDSA signing key pair (P-256) using noble-curves.
 * @returns A SigningKeyPair with keys as Uint8Array.
 */
export function generateSigningKeyPair(): SigningKeyPair {
  const privateKey = p256.utils.randomPrivateKey();
  const publicKey = p256.getPublicKey(privateKey, false); // Use uncompressed for consistency
  return {
    privateKey: privateKey,
    publicKey: publicKey,
  };
}

/**
 * Computes Diffie-Hellman shared secret using noble-curves (P-256).
 * @param privateKey Our ECDH private key bytes.
 * @param publicKey Their ECDH public key bytes (uncompressed or compressed).
 * @returns The shared secret as a Uint8Array (32 bytes, x-coordinate).
 */
export function computeDH(
  privateKey: ECDHPrivateKey,
  publicKey: ECDHPublicKey
): Uint8Array {
  // Noble’s getSharedSecret() returns a 65-byte array: [0x04, X (32 bytes), Y (32 bytes)].
  // We only need the 32-byte X-coordinate as the shared secret.
  const sharedPoint65 = p256.getSharedSecret(privateKey, publicKey);
  return sharedPoint65.subarray(1, 33);
}

/**
 * Derives keys using HKDF (HMAC-SHA256) via Web Crypto.
 * @param input The input key material (IKM) (ArrayBuffer or Uint8Array).
 * @param salt Optional salt (recommended) (ArrayBuffer or Uint8Array). Defaults to zero bytes.
 * @param info Optional context/application-specific info (ArrayBuffer or Uint8Array). Defaults to empty.
 * @param keyCount The number of output keys to derive.
 * @param keyLengthBytes The length of each derived key in bytes (default: 32).
 * @returns A Promise resolving to an array of derived keys (ArrayBuffer).
 */
export async function hkdfDerive(
  input: ArrayBuffer | Uint8Array,
  salt: ArrayBuffer | Uint8Array | null,
  info: ArrayBuffer | Uint8Array | null,
  keyCount: number,
  keyLengthBytes: number = 32
): Promise<ArrayBuffer[]> {
  const crypto = getCrypto();
  const saltBytes = salt ? new Uint8Array(salt) : new Uint8Array(32); // Default salt: 32 zeros
  const infoBytes = info ? new Uint8Array(info) : new Uint8Array(0); // Default info: empty
  const inputBytes = new Uint8Array(input);

  // 1. Import IKM as a temporary key for HKDF
  const ikmKey = await crypto.subtle.importKey(
    "raw",
    inputBytes,
    { name: "HKDF" },
    false,
    ["deriveKey"]
  );

  // 2. Derive the keys
  const derivedKeyPromises = [];
  for (let i = 0; i < keyCount; i++) {
    // Append counter to info for unique keys per derivation
    const currentInfo = concatBuffers(infoBytes, new Uint8Array([i]));
    derivedKeyPromises.push(
      crypto.subtle
        .deriveKey(
          {
            name: "HKDF",
            salt: saltBytes,
            info: currentInfo, // Use unique info for each key
            hash: HASH_ALGORITHM_NAME,
          },
          ikmKey,
          // Specify the algorithm for the *derived* key (HMAC in this case, but could be AES)
          // For raw bytes export, using HMAC or AES key type here doesn't strictly matter
          // as long as the length is correct and we export it raw.
          // Using HMAC as a common case for derived symmetric keys.
          {
            name: "HMAC",
            hash: HASH_ALGORITHM_NAME,
            length: keyLengthBytes * 8,
          },
          true, // Allow export
          ["sign", "verify"] // Permissions for the derived key (if kept as CryptoKey)
        )
        .then((key) => crypto.subtle.exportKey("raw", key)) // Export as raw bytes
    );
  }
  return Promise.all(derivedKeyPromises);
}

/**
 * Imports a raw key as an HMAC key (SHA-256) using Web Crypto.
 * @param keyData The raw key material (ArrayBuffer or Uint8Array).
 * @returns A Promise resolving to the HMACKey (CryptoKey).
 */
export async function importHmacKey(
  keyData: ArrayBuffer | Uint8Array
): Promise<HMACKey> {
  const crypto = getCrypto();
  // make the HMAC key extractable so we can export it when doing the DH‑ratchet
  return crypto.subtle.importKey(
    "raw",
    keyData,
    HMAC_ALGORITHM,
    /* extractable: */ true,
    ["sign", "verify"]
  );
}

/**
 * Imports a raw key as an AES-GCM key (256-bit) using Web Crypto.
 * @param keyData The raw key material (ArrayBuffer or Uint8Array, must be 32 bytes).
 * @returns A Promise resolving to the AESKey (CryptoKey).
 */
export async function importAesKey(
  keyData: ArrayBuffer | Uint8Array
): Promise<AESKey> {
  const keyBytes = new Uint8Array(keyData);
  if (keyBytes.length !== 32) {
    throw new Error(
      `AES key data must be 32 bytes, received ${keyBytes.length}`
    );
  }
  const crypto = getCrypto();
  return crypto.subtle.importKey("raw", keyBytes, AES_ALGORITHM, true, [
    "encrypt",
    "decrypt",
  ]);
}

/**
 * Signs data with an ECDSA private key (P-256 SHA-256) using noble-curves.
 * @param privateKey The ECDSAPrivateKey bytes to sign with.
 * @param data The Uint8Array data to sign.
 * @returns A Promise resolving to the signature as a Uint8Array (compact R/S format).
 */
export async function signData(
  privateKey: ECDSAPrivateKey,
  data: Uint8Array // Data to be signed (will be hashed)
): Promise<Uint8Array> {
  const messageHash = sha256(data); // Hash the data first
  // Use p256.sign, which returns a Signature object
  const signature = await p256.sign(messageHash, privateKey);
  // Convert to compact format (64 bytes R || S)
  return signature.toCompactRawBytes();
}

/**
 * Verifies an ECDSA signature (P-256 SHA-256) using noble-curves.
 * @param publicKey The ECDSAPublicKey bytes to verify with.
 * @param signature The signature Uint8Array (compact R/S format expected).
 * @param data The original data Uint8Array (will be hashed internally).
 * @returns A Promise resolving to true if the signature is valid, false otherwise.
 */
export async function verifySignature(
  publicKey: ECDSAPublicKey,
  signature: Uint8Array, // Expecting compact R/S format
  data: Uint8Array // The original data that was signed
): Promise<boolean> {
  const messageHash = sha256(data); // Hash the data first
  try {
    // Use p256.verify. It expects the signature in compact format or as a Signature object.
    // Passing the compact bytes directly is usually supported.
    return p256.verify(signature, messageHash, publicKey);
  } catch (error) {
    console.error("Signature verification failed:", error);
    return false;
  }
}

/**
 * Serializes an EC public key (Uint8Array) to a hex string.
 * @param publicKey The public key bytes.
 * @returns The hex string representation (SerializedECPublicKey).
 */
export function serializePublicKey(
  publicKey: ECDHPublicKey | ECDSAPublicKey
): SerializedECPublicKey {
  return bytesToHex(publicKey);
}

/**
 * Deserializes an EC public key from a hex string.
 * @param serialized The hex string representation.
 * @returns The public key as Uint8Array.
 */
export function deserializePublicKey(
  serialized: SerializedECPublicKey
): Uint8Array {
  // Add validation if needed (e.g., check length, format)
  return hexToBytes(serialized);
}

/**
 * Computes a SHA-256 hash of the input data using Web Crypto.
 * @param data The ArrayBuffer or Uint8Array data to hash.
 * @returns A Promise resolving to the hash digest as an ArrayBuffer (32 bytes).
 */
export async function hashData(
  data: ArrayBuffer | Uint8Array
): Promise<ArrayBuffer> {
  const crypto = getCrypto();
  return crypto.subtle.digest(HASH_ALGORITHM_NAME, data);
}

/**
 * Encrypts data using AES-GCM (256-bit) via Web Crypto.
 * @param key The AESKey (CryptoKey) to use for encryption.
 * @param plaintext The ArrayBuffer or Uint8Array data to encrypt.
 * @param iv The initialization vector (ArrayBuffer or Uint8Array, typically 12 bytes).
 * @param additionalData Optional additional authenticated data (AAD) (ArrayBuffer or Uint8Array).
 * @returns A Promise resolving to the ciphertext as an ArrayBuffer.
 */
export async function encryptAES(
  key: AESKey,
  plaintext: ArrayBuffer | Uint8Array,
  iv: ArrayBuffer | Uint8Array,
  additionalData?: ArrayBuffer | Uint8Array
): Promise<ArrayBuffer> {
  const crypto = getCrypto();
  const params: AesGcmParams = { name: AES_ALGORITHM.name, iv: iv };
  if (additionalData) {
    params.additionalData = additionalData;
  }
  return crypto.subtle.encrypt(params, key, plaintext);
}

/**
 * Decrypts data using AES-GCM (256-bit) via Web Crypto.
 * @param key The AESKey (CryptoKey) to use for decryption.
 * @param ciphertext The ArrayBuffer or Uint8Array data to decrypt.
 * @param iv The initialization vector (ArrayBuffer or Uint8Array) used during encryption.
 * @param additionalData Optional additional authenticated data (AAD) used during encryption.
 * @returns A Promise resolving to the original plaintext as an ArrayBuffer.
 */
export async function decryptAES(
  key: AESKey,
  ciphertext: ArrayBuffer | Uint8Array,
  iv: ArrayBuffer | Uint8Array,
  additionalData?: ArrayBuffer | Uint8Array
): Promise<ArrayBuffer> {
  const crypto = getCrypto();
  const params: AesGcmParams = { name: AES_ALGORITHM.name, iv: iv };
  if (additionalData) {
    params.additionalData = additionalData;
  }
  try {
    return await crypto.subtle.decrypt(params, key, ciphertext);
  } catch (e) {
    console.error("AES decryption failed:", e);
    throw new Error(
      `Decryption failed. Data may be corrupt or key/IV incorrect. ${e}`
    );
  }
}

/**
 * Exports a Web Crypto CryptoKey to its raw representation (ArrayBuffer).
 * @param key The CryptoKey to export (must be exportable and support 'raw' format).
 * @returns A Promise resolving to the raw key material as an ArrayBuffer.
 */
export async function exportRawKey(key: CryptoKey): Promise<ArrayBuffer> {
  const crypto = getCrypto();
  try {
    return await crypto.subtle.exportKey("raw", key);
  } catch (e) {
    console.error("Failed to export raw key:", e);
    throw new Error(`Could not export key in raw format: ${e}`);
  }
}

/**
 * Compares two public keys (Uint8Array) for equality using constant time buffer comparison.
 * @param keyA The first public key bytes.
 * @param keyB The second public key bytes.
 * @returns True if the keys are equal, false otherwise.
 */
export function equalPublicKeys(
  keyA: ECDHPublicKey | ECDSAPublicKey,
  keyB: ECDHPublicKey | ECDSAPublicKey
): boolean {
  // Use the imported equalBuffers function
  return equalBuffers(keyA, keyB);
}

```

```index.ts
/**
 * Triple Ratchet - Main exports
 */

// Re-export types and constants
export * from "./types";
export * from "./constants";

// Environment detection (Web Crypto)
export { getCrypto } from "./utils/environment";

// Buffer utilities
export {
  concatBuffers,
  equalBuffers,
  stringToBytes,
  bytesToString,
} from "./utils/buffer";

// Crypto utilities
export {
  generateECDHKeyPair,
  generateSigningKeyPair,
  computeDH,
  hkdfDerive,
  importHmacKey,
  importAesKey,
  encryptAES,
  decryptAES,
  exportRawKey,
  equalPublicKeys,
  verifySignature,
  serializePublicKey,
  deserializePublicKey,
  hashData,
  signData,
} from "./crypto/crypto-utils";

// Ratchet protocol functions
export {
  createIdentityState,
  createPreKeyBundle,
  initializeRatchetInitiator,
  initializeRatchetReceiver,
  ratchetEncrypt,
  ratchetDecrypt,
} from "./protocol/ratchet-logic";

```

```protocol\ratchet-logic.ts
// === File: src/protocol/ratchet-logic.ts ===

import { p256 } from "@noble/curves/p256"; // For P256_ORDER and utils
import { sha256 } from "@noble/hashes/sha256"; // For hashing in enhancement
import { bytesToHex, hexToBytes } from "@noble/hashes/utils"; // Import hexToBytes

import {
  INFO_RATCHET,
  MAX_SKIP,
  P256_ORDER, // Import curve order
  HMAC_ALGORITHM, // Added import
} from "../constants";
// Import generateSigningKeyPair
import {
  generateECDHKeyPair,
  generateSigningKeyPair, // Added import
  computeDH,
  hkdfDerive,
  importHmacKey,
  importAesKey,
  encryptAES,
  decryptAES,
  exportRawKey,
  equalPublicKeys,
  verifySignature,
  hashData,
  signData,
} from "../crypto/crypto-utils";
import {
  concatBuffers,
  equalBuffers, // For general buffer comparison if needed
  stringToBytes,
  bytesToString,
} from "../utils/buffer";
import { getCrypto } from "../utils/environment"; // Added import

// Import MessageType as a value, not just a type
import {
  MessageType, // Changed from 'import type'
  type RatchetState, // Keep others as type imports if only used as types
  type RatchetChainState,
  type IdentityState,
  type MessageKeys,
  type HMACKey, // Web Crypto type
  type AESKey, // Web Crypto type
  type RatchetMessage,
  type MessageHeader,
  type PreKeyBundle,
  type ECKeyPair, // Uses Uint8Array keys now
  type ECDHPrivateKey, // Uint8Array
  type ECDHPublicKey, // Uint8Array
} from "../types";

// --- Helper Functions ---

/**
 * Converts a BigInt to a 32-byte Uint8Array (big-endian).
 * Pads with leading zeros if necessary. Truncates if necessary (unlikely for curve scalars).
 * @param num The BigInt to convert.
 * @returns A 32-byte Uint8Array.
 */
function bigIntTo32Bytes(num: bigint): Uint8Array {
  let hex = num.toString(16);
  // Ensure even length for hex bytes
  if (hex.length % 2) {
    hex = "0" + hex;
  }
  // Ensure 64 hex characters (32 bytes) by padding with leading zeros
  // Truncate *before* padding if hex is too long (e.g., from negative modulo)
  if (hex.length > 64) {
    console.warn(
      `BigInt hex representation ${hex} is longer than 32 bytes, taking last 64 chars.`
    );
    hex = hex.slice(-64);
  }
  hex = hex.padStart(64, "0");

  return hexToBytes(hex);
}

/**
 * Converts a Uint8Array to a BigInt. Assumes big-endian format.
 * @param bytes The input bytes.
 * @returns The corresponding BigInt.
 */
function bytesToBigInt(bytes: Uint8Array): bigint {
  let hex = bytesToHex(bytes); // Use imported bytesToHex
  if (hex.length % 2) {
    hex = "0" + hex;
  }
  // Handle empty string case
  if (hex === "") {
    return 0n;
  }
  return BigInt("0x" + hex);
}

// --- Symmetric Key Ratchet (Chain Key) Logic ---

/**
 * Derives message keys (AES encryption key, HMAC auth key, IV) from a chain key state.
 * Uses Web Crypto keys. Does not advance the chain state itself.
 * @param chainKey The current HMAC chain key (CryptoKey).
 * @returns A Promise resolving to the MessageKeys.
 */
async function deriveMessageKeysFromChainKey(
  chainKey: HMACKey
): Promise<MessageKeys> {
  const crypto = getCrypto();
  const messageKeyInput = stringToBytes("MessageKey"); // Constant input for message key derivation

  // Use HMAC-SHA256 with the chain key to derive the input for HKDF
  const derivedCombinedKeyMaterial = await crypto.subtle.sign(
    HMAC_ALGORITHM,
    chainKey,
    messageKeyInput
  );

  // Use HKDF to derive the actual encryption and authentication keys + IV
  // Using a fixed salt (null) and info specific to this derivation step
  const keys = await hkdfDerive(
    derivedCombinedKeyMaterial,
    null, // Salt (optional, could use a fixed one)
    INFO_RATCHET, // Context info
    3, // Derive 3 keys: AES key, Auth key, IV base
    32 // Each key material is 32 bytes
  );
  const rawEnc = new Uint8Array(keys[0]);
  const rawAuth = new Uint8Array(keys[1]);
  const rawIvMat = new Uint8Array(keys[2]);
  console.debug("🔑 [HKDF] rawEncKey: ", bytesToHex(rawEnc));
  console.debug("🔑 [HKDF] rawAuthKey:", bytesToHex(rawAuth));
  console.debug(
    "🔑 [HKDF] rawIvMat (first 12 bytes):",
    bytesToHex(rawIvMat.slice(0, 12))
  );

  const iv = keys[2].slice(0, 12); // Use first 12 bytes of the third derived key as IV
  console.debug("🔑 [Encrypt] rawEncKey:", bytesToHex(new Uint8Array(keys[0])));
  console.debug(
    "🔑 [Encrypt] rawAuthKey:",
    bytesToHex(new Uint8Array(keys[1]))
  );
  console.debug(
    "🔑 [Encrypt] rawIv:",
    bytesToHex(new Uint8Array(keys[2]).slice(0, 12))
  );
  return {
    encKey: await importAesKey(keys[0]), // Import raw bytes as AES key
    authKey: await importHmacKey(keys[1]), // Import raw bytes as HMAC key
    iv: iv,
  };
}

/**
 * Advances a chain key state to the next key in the sequence.
 * Uses Web Crypto keys.
 * @param chainKey The current HMAC chain key (CryptoKey).
 * @returns A Promise resolving to the next HMAC chain key (CryptoKey).
 */
async function advanceChainKey(chainKey: HMACKey): Promise<HMACKey> {
  const crypto = getCrypto();
  const nextKeyInput = stringToBytes("NextChainKey"); // Constant input for next chain key derivation

  // Use HMAC-SHA256 with the current chain key to derive the next chain key material
  const nextKeyMaterial = await crypto.subtle.sign(
    HMAC_ALGORITHM,
    chainKey,
    nextKeyInput
  );

  // Import the derived material as the new HMAC chain key
  return importHmacKey(nextKeyMaterial);
}

/**
 * Gets a message key from a symmetric ratchet chain state for a specific counter.
 * Advances the chain state past the requested counter and stores skipped keys.
 * @param chainState The current state of the symmetric ratchet chain.
 * @param counter The desired message counter index.
 * @returns A Promise resolving to an object containing the MessageKeys and the updated RatchetChainState.
 */
export async function getSymRatchetMessageKey(
  chainState: RatchetChainState,
  counter: number
): Promise<{ messageKeys: MessageKeys; nextChainState: RatchetChainState }> {
  let currentChainKey = chainState.chainKey;
  let currentIndex = chainState.chainIndex;
  const newSkippedKeys = new Map(chainState.skippedMessageKeys); // Copy skipped keys

  // Check if the requested key is already skipped
  if (newSkippedKeys.has(counter)) {
    const messageKeys = newSkippedKeys.get(counter)!;
    newSkippedKeys.delete(counter); // Consume the skipped key
    console.debug(
      `Used skipped message key for index ${counter}. Remaining skipped: ${newSkippedKeys.size}`
    );
    return {
      messageKeys,
      nextChainState: { ...chainState, skippedMessageKeys: newSkippedKeys },
    };
  }

  // Check if the requested counter is in the past (and not skipped)
  if (counter < currentIndex) {
    throw new Error(
      `Message key for past counter ${counter} not found (current index: ${currentIndex})`
    );
  }

  // Check if too many messages would need to be skipped
  if (counter - currentIndex > MAX_SKIP) {
    throw new Error(
      `Skipping too many messages (${counter - currentIndex}, max: ${MAX_SKIP})`
    );
  }

  // Advance the chain until the desired counter is reached
  while (currentIndex < counter) {
    console.debug(`Skipping message key for index ${currentIndex}`);
    const messageKeys = await deriveMessageKeysFromChainKey(currentChainKey);
    newSkippedKeys.set(currentIndex, messageKeys); // Store the skipped key
    currentChainKey = await advanceChainKey(currentChainKey); // Advance the chain key
    currentIndex++;

    // Optional: Prune very old skipped keys if the map grows too large
    if (newSkippedKeys.size > MAX_SKIP * 2) {
      // Example pruning strategy
      const oldestKeyIndex = Math.min(...newSkippedKeys.keys());
      if (currentIndex - oldestKeyIndex > MAX_SKIP * 2) {
        newSkippedKeys.delete(oldestKeyIndex);
        console.warn(`Pruned old skipped key for index ${oldestKeyIndex}`);
      }
    }
  }

  // Derive the keys for the requested counter
  const requestedMessageKeys = await deriveMessageKeysFromChainKey(
    currentChainKey
  );
  // Advance the chain key one more time for the next state
  const nextChainKey = await advanceChainKey(currentChainKey);
  const nextIndex = currentIndex + 1;

  // Create the next chain state
  const nextState: RatchetChainState = {
    chainKey: nextChainKey,
    chainIndex: nextIndex,
    skippedMessageKeys: newSkippedKeys,
  };

  return { messageKeys: requestedMessageKeys, nextChainState: nextState };
}

// --- Diffie-Hellman (DH) Ratchet Logic ---

/**
 * Performs the DH ratchet step calculation using Web Crypto HKDF.
 * Derives a new root key and a new chain key from the DH result and the current root key.
 * @param rootKey The current root key (HMACKey - CryptoKey).
 * @param dhOutput The result of the ECDH computation (Uint8Array).
 * @returns A Promise resolving to { newRootKey: HMACKey, newChainKey: HMACKey }.
 */
async function performDHRatchetStep(
  rootKey: HMACKey,
  dhOutput: Uint8Array
): Promise<{ newRootKey: HMACKey; newChainKey: HMACKey }> {
  // Export the current root key to use as salt in HKDF
  const rootKeyRaw = await exportRawKey(rootKey);

  // Derive two new 32-byte keys using HKDF
  // Input: DH output
  // Salt: Current root key raw bytes
  // Info: Constant ratchet info
  const derivedKeys = await hkdfDerive(dhOutput, rootKeyRaw, INFO_RATCHET, 2);

  // Import the derived raw bytes as new CryptoKeys
  const newRootKey = await importHmacKey(derivedKeys[0]);
  const newChainKey = await importHmacKey(derivedKeys[1]); // This becomes the key for the *receiving* chain after a DH step

  return { newRootKey, newChainKey };
}

// --- Triple Ratchet Enhancement ---

/**
 * Calculates the "enhanced" private key for the Triple Ratchet: x_t' = (x_t * H(I_t)) mod n
 * Uses noble-curves for modular arithmetic.
 * @param privateKeyBytes The original private key scalar bytes (x_t).
 * @param sharedSecret The shared secret derived via DH (I_t) (Uint8Array).
 * @returns The enhanced private key bytes (x_t'). Note: This is now synchronous.
 */
function calculateEnhancedPrivateKey(
  privateKeyBytes: ECDHPrivateKey,
  sharedSecret: Uint8Array // I_t
): ECDHPrivateKey {
  // 1. Hash the shared secret: H(I_t)
  const hashedSecretBytes = sha256(sharedSecret); // Use noble sha256 (synchronous)

  // 2. Convert private key and hash to BigInt scalars
  const privateScalar = bytesToBigInt(privateKeyBytes);
  const hashScalar = bytesToBigInt(hashedSecretBytes);

  // 3. Perform modular multiplication: (x_t * H(I_t)) mod n
  // Use BigInt modulo operator as p256.utils.mod was causing issues
  let enhancedScalar = (privateScalar * hashScalar) % P256_ORDER;
  // Ensure result is positive (BigInt % can return negative)
  if (enhancedScalar < 0n) {
    enhancedScalar += P256_ORDER;
  }

  // 4. Convert the resulting BigInt scalar back to 32 bytes
  // Use helper function as p256.utils.scalarToBytes was causing issues
  const enhancedPrivateKeyBytes = bigIntTo32Bytes(enhancedScalar);

  console.debug("Triple Ratchet: Enhanced private key calculated.");
  return enhancedPrivateKeyBytes;
}

// --- Ratchet Initialization Logic ---

/**
 * Initializes the RatchetState for the initiator using the recipient's PreKeyBundle.
 * Uses noble-curves for EC operations.
 * @param ownIdentityState Our identity information.
 * @param preKeyBundle The recipient's PreKeyBundle.
 * @returns A Promise resolving to the initial RatchetState for the initiator.
 */
export async function initializeRatchetInitiator(
  ownIdentityState: IdentityState,
  preKeyBundle: PreKeyBundle
): Promise<RatchetState> {
  // 1. Verify the signed prekey signature
  const isSignatureValid = await verifySignature(
    preKeyBundle.signingKey, // Bob's public signing key
    preKeyBundle.signedPreKeySignature, // The signature Bob provided
    preKeyBundle.signedPreKey // The public key that was signed
  );
  if (!isSignatureValid) {
    throw new Error("Invalid signature on signed prekey in PreKeyBundle.");
  }
  console.log("Signed pre-key signature verified.");

  // 2. Generate our ephemeral key pair for this session (EKa)
  const ephemeralKeyPair = generateECDHKeyPair();
  console.log("Generated ephemeral key pair for initiator.");

  // 3. Perform X3DH calculations (Alice's perspective)
  // DH1: Alice's Identity Private Key (IKa) <-> Bob's Signed PreKey Public Key (SPKb)
  const dh1 = computeDH(
    ownIdentityState.dhKeyPair.privateKey,
    preKeyBundle.signedPreKey
  );
  // DH2: Alice's Ephemeral Private Key (EKa) <-> Bob's Identity Public Key (IKb)
  const dh2 = computeDH(ephemeralKeyPair.privateKey, preKeyBundle.identityKey);
  // DH3: Alice's Ephemeral Private Key (EKa) <-> Bob's Signed PreKey Public Key (SPKb)
  const dh3 = computeDH(ephemeralKeyPair.privateKey, preKeyBundle.signedPreKey);
  // DH4: Alice's Ephemeral Private Key (EKa) <-> Bob's One-Time PreKey Public Key (OPKb)
  const dh4 = computeDH(ephemeralKeyPair.privateKey, preKeyBundle.preKey);
  console.log("Performed X3DH calculations.");

  // 4. Combine DH outputs -> Shared Secret (SK)
  // Concatenate in a defined order (e.g., FFFFFF || DH1 || DH2 || DH3 || DH4)
  // Using a simpler concatenation for this example: DH1 || DH2 || DH3 || DH4
  const sharedSecretInput = concatBuffers(dh1, dh2, dh3, dh4);

  // 5. Derive initial Root Key from SK using HKDF
  // Use SK as IKM, no salt, standard info
  const initialKeys = await hkdfDerive(
    sharedSecretInput,
    null, // No salt for initial derivation from SK
    INFO_RATCHET,
    1 // Derive 1 key (the root key)
  );
  const initialRootKey = await importHmacKey(initialKeys[0]);
  console.log("Derived initial root key.");

  // 6. Generate our first ratchet key pair (RKa_0)
  const initialRatchetKeyPair = generateECDHKeyPair();
  console.log("Generated initial sending ratchet key pair.");

  // 7. Initial "enhanced" private key is just the normal private key (x'_0 = x_0)
  // The enhancement happens *after* the first DH calculation using this key.
  const initialEnhancedPrivateKey = initialRatchetKeyPair.privateKey;

  // 8. Initial State Setup for Alice (Initiator)
  const initialState: RatchetState = {
    identityPrivateKey: ownIdentityState.dhKeyPair.privateKey,
    identityPublicKey: ownIdentityState.dhKeyPair.publicKey,
    remoteIdentityKey: preKeyBundle.identityKey, // Bob's Identity Key
    remoteSigningKey: preKeyBundle.signingKey, // Bob's Signing Key
    rootKey: initialRootKey,
    ourRatchetKeyPair: initialRatchetKeyPair, // Alice's first ratchet key (RKa_0)
    theirRatchetKey: preKeyBundle.signedPreKey, // Alice assumes Bob's first key is SPKb initially ??? Should this be null until first message? X3DH implies SPKb is used in initial calculation, but Bob's first *ratchet* key RKb_0 is unknown. Let's set to null.
    // theirRatchetKey: null, // Bob's ratchet key is unknown until his first message
    ourEnhancedPrivateKey: initialEnhancedPrivateKey, // x'_0
    sendingChain: null, // Will be created on first send
    receivingChain: null, // Will be created on first receive
    sendMsgCounter: 0,
    recvMsgCounter: 0, // Not strictly needed, chainIndex tracks progress
    prevSendMsgCounter: 0,
    skippedRatchetKeys: new Map(),
  };

  // Correction: In X3DH, the initial symmetric key is derived, but the Double Ratchet
  // part starts *after* this. Alice needs Bob's SignedPreKey to calculate SK,
  // but Bob's first *ratchet* key (RKb_0) is sent in his first reply message.
  // However, Alice needs *something* to perform the first DH ratchet step *with* when she sends
  // her first message. Signal protocol uses Bob's Signed PreKey (SPKb) as the initial `theirRatchetKey`
  // for Alice. Let's stick with that.
  initialState.theirRatchetKey = preKeyBundle.signedPreKey;

  console.log("Initiator state initialized.");
  return initialState;
}

/**
 * Initializes the RatchetState for the receiver using the first PreKey message.
 * Uses noble-curves for EC operations.
 * @param ownIdentityState Our identity information (needs pre-keys).
 * @param preKeyMessage The received PreKey message.
 * @returns A Promise resolving to the initial RatchetState for the receiver.
 */
export async function initializeRatchetReceiver(
  ownIdentityState: IdentityState,
  preKeyMessage: RatchetMessage
): Promise<RatchetState> {
  console.log("Initializing receiver state from PreKey message.");
  // 1. Validate PreKey message structure
  if (
    // Use MessageType enum value
    preKeyMessage.type !== MessageType.PRE_KEY ||
    !preKeyMessage.identityKey || // Alice's IKa pub
    !preKeyMessage.header.publicKey || // Alice's EKa pub
    preKeyMessage.preKeyId === undefined || // ID of OPKb used by Alice
    preKeyMessage.signedPreKeyId === undefined // ID of SPKb used by Alice
  ) {
    throw new Error("Invalid PreKey message structure for initialization.");
  }
  console.log("PreKey message structure validated.");

  // 2. Retrieve our necessary private keys (Bob's perspective)
  // Need SPKb priv and OPKb priv based on IDs in message
  const ownSignedPreKeyPair = await getSignedPreKeyPair(
    ownIdentityState, // Bob's identity state
    preKeyMessage.signedPreKeyId // The ID of the SPKb Alice used
  );
  const ownPreKeyPair = await getOneTimePreKeyPair(
    ownIdentityState, // Bob's identity state
    preKeyMessage.preKeyId // The ID of the OPKb Alice used
  );
  if (!ownSignedPreKeyPair || !ownPreKeyPair) {
    throw new Error(
      `Required pre-key (ID ${preKeyMessage.preKeyId}) or signed pre-key (ID ${preKeyMessage.signedPreKeyId}) not found.`
    );
  }
  console.log("Retrieved own pre-keys for X3DH.");

  // 3. Perform X3DH calculations (Bob's perspective)
  // DH1: Bob's Signed PreKey Private Key (SPKb) <-> Alice's Identity Public Key (IKa)
  const dh1 = computeDH(
    ownSignedPreKeyPair.privateKey,
    preKeyMessage.identityKey
  );
  // DH2: Bob's Identity Private Key (IKb) <-> Alice's Ephemeral Public Key (EKa)
  const dh2 = computeDH(
    ownIdentityState.dhKeyPair.privateKey,
    preKeyMessage.header.publicKey
  );
  // DH3: Bob's Signed PreKey Private Key (SPKb) <-> Alice's Ephemeral Public Key (EKa)
  const dh3 = computeDH(
    ownSignedPreKeyPair.privateKey,
    preKeyMessage.header.publicKey
  );
  // DH4: Bob's One-Time PreKey Private Key (OPKb) <-> Alice's Ephemeral Public Key (EKa)
  const dh4 = computeDH(
    ownPreKeyPair.privateKey,
    preKeyMessage.header.publicKey
  );
  console.log("Performed X3DH calculations.");

  // 4. Combine DH outputs -> Shared Secret (SK) - Must match Alice's calculation
  const sharedSecretInput = concatBuffers(dh1, dh2, dh3, dh4);

  // 5. Derive initial Root Key from SK
  const initialKeys = await hkdfDerive(
    sharedSecretInput,
    null,
    INFO_RATCHET,
    1
  );
  const initialRootKey = await importHmacKey(initialKeys[0]);
  console.log("Derived initial root key.");

  // 6. Alice's ephemeral key (EKa pub) is our first "theirRatchetKey"
  const initialTheirRatchetKey = preKeyMessage.header.publicKey;

  // 7. Generate our first ratchet key pair (RKb_0)
  const initialRatchetKeyPair = ownSignedPreKeyPair;
  console.log("Generated initial receiving ratchet key pair.");

  // 8. Initial "enhanced" private key is just the normal private key (y'_0 = y_0)
  const initialEnhancedPrivateKey = initialRatchetKeyPair.privateKey;

  // 9. Initial State Setup for Bob (Receiver)
  // Bob needs Alice's signing key to verify future messages.
  // This should ideally be part of the PreKey message or fetched separately.
  // Assuming Alice's IKa *is* her signing key for simplicity here.
  const remoteSigningKey = preKeyMessage.identityKey; // Placeholder assumption

  const initialState: RatchetState = {
    identityPrivateKey: ownIdentityState.dhKeyPair.privateKey, // Bob's IKb priv
    identityPublicKey: ownIdentityState.dhKeyPair.publicKey, // Bob's IKb pub
    remoteIdentityKey: preKeyMessage.identityKey, // Alice's IKa pub
    remoteSigningKey: remoteSigningKey, // Alice's Signing Key pub (placeholder)
    rootKey: initialRootKey,
    ourRatchetKeyPair: initialRatchetKeyPair, // Bob's first ratchet key (RKb_0)
    theirRatchetKey: initialTheirRatchetKey, // Alice's first ratchet key (RKa_0 pub)
    ourEnhancedPrivateKey: initialEnhancedPrivateKey, // y'_0
    sendingChain: null, // Will be created by first send
    receivingChain: null, // Will be created by first decrypt call
    sendMsgCounter: 0,
    recvMsgCounter: 0,
    prevSendMsgCounter: 0,
    skippedRatchetKeys: new Map(),
  };
  console.log("Receiver state initialized.");
  return initialState;
}

// --- Encryption Logic ---

/**
 * Encrypts a plaintext message using the current RatchetState.
 * Handles DH ratchet updates and Triple Ratchet enhancement.
 * @param currentState The current RatchetState.
 * @param plaintext The plaintext ArrayBuffer to encrypt.
 * @returns A Promise resolving to { message: RatchetMessage, nextState: RatchetState }.
 */
export async function ratchetEncrypt(
  currentState: RatchetState,
  plaintext: ArrayBuffer
): Promise<{ message: RatchetMessage; nextState: RatchetState }> {
  let nextState = { ...currentState }; // Copy state to modify
  let sendingChain = nextState.sendingChain;
  let currentRatchetKeyPair = nextState.ourRatchetKeyPair; // Key pair used for DH/header

  // --- DH Ratchet Step (if sendingChain is null, means we need a new one) ---
  if (!sendingChain) {
    console.log("Performing DH ratchet step before sending.");
    if (!nextState.theirRatchetKey) {
      // This should not happen after initialization
      throw new Error("Cannot encrypt: Remote ratchet key not established.");
    }

    // DH calculation using the *current* enhanced private key (x'_t or y'_t) and their public key
    const dhOutput = computeDH(
      nextState.ourEnhancedPrivateKey, // Use the enhanced key x'_t
      nextState.theirRatchetKey // Their Rk pub (RK_other)
    );
    console.log("Calculated DH output for new chain.");

    // Derive new root key and sending chain key
    const { newRootKey, newChainKey } = await performDHRatchetStep(
      nextState.rootKey,
      dhOutput
    );
    console.log("Derived new root key and sending chain key.");

    // Initialize the new sending chain
    sendingChain = {
      chainKey: newChainKey,
      chainIndex: 0,
      skippedMessageKeys: new Map(),
    };
    nextState.rootKey = newRootKey;
    nextState.sendingChain = sendingChain;
    nextState.sendMsgCounter = 0; // Reset message counter for the new chain
    nextState.prevSendMsgCounter = currentState.sendMsgCounter; // Store previous chain's count

    // --- Triple Ratchet Enhancement (Sender Side) ---
    // Generate the *next* ratchet key pair (RK_our, t+1)
    const nextRatchetKeyPair = generateECDHKeyPair();
    console.log("Generated next ratchet key pair.");

    // Calculate the *next* enhanced private key (x'_{t+1} or y'_{t+1})
    // This uses the *newly generated* private key (x_{t+1}) and the *just calculated* DH output (I_t)
    const nextEnhancedPrivateKey = calculateEnhancedPrivateKey(
      nextRatchetKeyPair.privateKey, // x_{t+1}
      dhOutput // I_t
    );
    console.log("Calculated next enhanced private key.");

    // Update state with the *new* key pair and *new* enhanced key for the *next* DH step
    nextState.ourRatchetKeyPair = nextRatchetKeyPair; // Store RK_our, t+1
    nextState.ourEnhancedPrivateKey = nextEnhancedPrivateKey; // Store x'_{t+1}
    currentRatchetKeyPair = currentState.ourRatchetKeyPair; // The message header uses the *old* public key RK_our, t
  } // End DH Ratchet Step

  // --- Symmetric Ratchet Step ---
  if (!sendingChain) {
    // Should be impossible if DH step logic is correct
    throw new Error(
      "Internal error: Sending chain not available after DH check."
    );
  }

  const currentSendCounter = nextState.sendMsgCounter; // Counter for this message (N)
  console.log(`Encrypting message ${currentSendCounter} in current chain.`);
  const { messageKeys, nextChainState: updatedSendingChain } =
    await getSymRatchetMessageKey(sendingChain, currentSendCounter);
  nextState.sendingChain = updatedSendingChain; // Update chain state (key advanced, index incremented)
  nextState.sendMsgCounter = currentSendCounter + 1; // Increment message counter for next time

  // --- AES Encryption ---
  const headerPublicKey = currentRatchetKeyPair.publicKey; // Public key corresponding to the private key used for DH (RK_our, t pub)
  // Construct Associated Data (AD) - must be the same for encryption and decryption
  const adObject = {
    pk: bytesToHex(headerPublicKey), // Include sender's public key used for DH
    pn: nextState.prevSendMsgCounter, // Previous chain message count
    n: currentSendCounter, // Current chain message count
  };
  const aadBuffer = stringToBytes(JSON.stringify(adObject)); // Serialize AD to bytes

  console.log("Encrypting plaintext with AES-GCM.");
  const rawEncKey = new Uint8Array(await exportRawKey(messageKeys.encKey));
  console.debug("🔑 [Encrypt] encKey:", bytesToHex(rawEncKey));
  console.debug("🔑 [Encrypt] iv:", bytesToHex(new Uint8Array(messageKeys.iv)));
  console.debug("🔑 [Encrypt] aad:", new TextDecoder().decode(aadBuffer));
  const ciphertext = await encryptAES(
    messageKeys.encKey, // AES key from symmetric ratchet
    plaintext,
    messageKeys.iv, // IV from symmetric ratchet
    aadBuffer // Authenticated Data
  );

  // --- Construct Message ---
  const header: MessageHeader = {
    publicKey: headerPublicKey, // RK_our, t pub
    previousCounter: nextState.prevSendMsgCounter, // PN
    messageCounter: currentSendCounter, // N
  };

  // Determine if this is the very first message (PreKey type)
  const isInitialMessage =
    currentState.sendMsgCounter === 0 &&
    currentState.prevSendMsgCounter === 0 &&
    !currentState.receivingChain && // Check if we haven't received anything yet
    currentState.theirRatchetKey !== null; // Ensure we have a key to send to

  const message: RatchetMessage = {
    // Use MessageType enum value
    type: isInitialMessage ? MessageType.PRE_KEY : MessageType.NORMAL,
    header,
    ciphertext,
  };

  // Add extra fields for PreKey messages
  if (message.type === MessageType.PRE_KEY) {
    console.log("Creating PreKey message.");
    message.identityKey = nextState.identityPublicKey; // Our IKa pub
    // These IDs need to correspond to the keys Bob actually used from the bundle
    // This requires the initiator state to remember which keys were used.
    // For now, using placeholders. This needs proper handling based on PreKeyBundle.
    message.preKeyId = 0; // Placeholder - should be bundle.preKeyId
    message.signedPreKeyId = 0; // Placeholder - should be bundle.signedPreKeyId
  }

  console.log(
    `Encryption complete. Type: ${MessageType[message.type]}, N: ${
      header.messageCounter
    }, PN: ${header.previousCounter}`
  );
  return { message, nextState };
}

// --- Decryption Logic ---

/**
 * Creates a unique key for storing/retrieving skipped message keys based on header info.
 * Key format: N:Hex(PublicKey) - N is message counter in the chain associated with PublicKey
 * @param header The message header containing the public key and message counter.
 * @returns A unique string key.
 */
function getSkippedKeyLookupKey(header: MessageHeader): string {
  const pkHex = bytesToHex(header.publicKey);
  // The key identifies a message key within a specific chain (identified by pkHex)
  return `${header.messageCounter}:${pkHex}`;
}

/**
 * Decrypts a received RatchetMessage using the current RatchetState.
 * Handles DH ratchet updates, Triple Ratchet enhancement, and skipped keys.
 * @param currentState The current RatchetState.
 * @param message The received RatchetMessage.
 * @returns A Promise resolving to { plaintext: ArrayBuffer, nextState: RatchetState }.
 */
export async function ratchetDecrypt(
  currentState: RatchetState,
  message: RatchetMessage
): Promise<{ plaintext: ArrayBuffer; nextState: RatchetState }> {
  let nextState = { ...currentState }; // Copy state
  let plaintext: ArrayBuffer | null = null;
  const header = message.header;

  console.log(
    `Attempting to decrypt message Type: ${MessageType[message.type]}, N: ${
      header.messageCounter
    }, PN: ${header.previousCounter}, PubKey: ${bytesToHex(header.publicKey)}`
  );

  // --- Try Decrypting with Skipped Keys First ---
  // Check if we have a skipped key corresponding to this message's header info
  const skippedKeyLookup = getSkippedKeyLookupKey(header);
  const skippedMessageKeys = nextState.skippedRatchetKeys.get(skippedKeyLookup);

  if (skippedMessageKeys) {
    console.log(
      `Found skipped message key for N=${
        header.messageCounter
      }, PubKey=${bytesToHex(header.publicKey)}. Attempting decryption.`
    );
    const adObject = {
      pk: bytesToHex(header.publicKey),
      pn: header.previousCounter,
      n: header.messageCounter,
    };
    const aadBuffer = stringToBytes(JSON.stringify(adObject));

    try {
      plaintext = await decryptAES(
        skippedMessageKeys.encKey,
        message.ciphertext,
        skippedMessageKeys.iv,
        aadBuffer
      );
      console.log("Decryption successful using skipped key.");

      // Remove the used skipped key
      const updatedSkipped = new Map(nextState.skippedRatchetKeys);
      updatedSkipped.delete(skippedKeyLookup);
      nextState.skippedRatchetKeys = updatedSkipped;

      return { plaintext, nextState }; // Return successfully decrypted message and updated state
    } catch (error) {
      console.error("Decryption failed using skipped key:", error);
      // If decryption fails even with a skipped key, something is wrong.
      // Don't proceed further with this key. Remove it.
      const updatedSkipped = new Map(nextState.skippedRatchetKeys);
      updatedSkipped.delete(skippedKeyLookup);
      nextState.skippedRatchetKeys = updatedSkipped;
      // Re-throw or handle as a critical error, as the skipped key was invalid.
      throw new Error(
        `Decryption failed even with skipped key for N=${header.messageCounter}. Message might be corrupt or state desynchronized.`
      );
    }
  }
  console.log("No suitable skipped key found. Proceeding with ratchet steps.");

  // --- Check for DH Ratchet Step ---
  let receivingChain = nextState.receivingChain;
  let performDH = false;

  // Perform DH if:
  // 1. We don't have a receiving chain yet (first message after our DH step)
  // 2. The public key in the message header is different from the one we expected for the current receiving chain
  if (
    !receivingChain ||
    (nextState.theirRatchetKey &&
      !equalPublicKeys(nextState.theirRatchetKey, header.publicKey))
  ) {
    performDH = true;
    console.log(
      `Detected need for DH ratchet step. Current theirRatchetKey: ${
        nextState.theirRatchetKey
          ? bytesToHex(nextState.theirRatchetKey)
          : "null"
      }, Message PubKey: ${bytesToHex(header.publicKey)}`
    );
  }

  if (performDH) {
    // --- Store Skipped Message Keys from Old Chain ---
    if (receivingChain && nextState.theirRatchetKey) {
      console.log(
        `Storing skipped message keys from old receiving chain (associated with PubKey: ${bytesToHex(
          nextState.theirRatchetKey
        )}) up to index ${header.previousCounter}.`
      );
      const oldSkipped = new Map(nextState.skippedRatchetKeys); // Start with existing globally skipped keys
      const oldRemotePubKey = nextState.theirRatchetKey; // The key associated with the old chain

      // Add keys already skipped within the old chain state itself
      for (const [idx, keys] of receivingChain.skippedMessageKeys.entries()) {
        const keyLookup = getSkippedKeyLookupKey({
          publicKey: oldRemotePubKey,
          previousCounter: 0, // PN is not relevant for identifying the key itself
          messageCounter: idx,
        });
        if (!oldSkipped.has(keyLookup)) {
          oldSkipped.set(keyLookup, keys);
          console.log(` -> Stored internally skipped key for index ${idx}`);
        }
      }

      // Advance the old chain up to PN (previousCounter) and store those keys too
      let tempChainKey = receivingChain.chainKey;
      const startIndex = receivingChain.chainIndex;
      const endIndex = header.previousCounter; // PN from the message header
      if (endIndex < startIndex) {
        console.warn(
          `Message PN (${endIndex}) is less than current chain index (${startIndex}). Cannot skip future keys.`
        );
      } else {
        const numToSkip = Math.min(endIndex - startIndex, MAX_SKIP); // Limit skipping
        console.log(
          `Advancing old chain from ${startIndex} up to ${
            startIndex + numToSkip
          } (max ${endIndex}) to store skipped keys.`
        );
        for (let i = 0; i < numToSkip; i++) {
          const currentIdx = startIndex + i;
          const keys = await deriveMessageKeysFromChainKey(tempChainKey);
          const keyLookup = getSkippedKeyLookupKey({
            publicKey: oldRemotePubKey,
            previousCounter: 0,
            messageCounter: currentIdx,
          });
          if (!oldSkipped.has(keyLookup)) {
            oldSkipped.set(keyLookup, keys);
            console.log(` -> Stored newly skipped key for index ${currentIdx}`);
          }
          tempChainKey = await advanceChainKey(tempChainKey);
        }
      }
      nextState.skippedRatchetKeys = oldSkipped; // Update the global skipped keys map
      console.log(
        `Finished storing skipped keys. Total skipped: ${nextState.skippedRatchetKeys.size}`
      );
    } // End storing skipped keys

    // --- Perform DH Ratchet Calculation ---
    console.log("Performing DH calculation for new receiving chain.");
    // Use our *current* enhanced private key (y'_t) and the *sender's* public key from the header (RK_sender, t pub)
    const dhOutput = computeDH(
      nextState.ourEnhancedPrivateKey, // y'_t
      header.publicKey // RK_sender, t pub
    );
    const { newRootKey, newChainKey } = await performDHRatchetStep(
      nextState.rootKey,
      dhOutput
    );
    console.log("Derived new root key and receiving chain key.");

    // Initialize the new receiving chain
    receivingChain = {
      chainKey: newChainKey,
      chainIndex: 0,
      skippedMessageKeys: new Map(),
    };
    nextState.rootKey = newRootKey;
    nextState.receivingChain = receivingChain;
    nextState.theirRatchetKey = header.publicKey; // Update expected sender key
    nextState.recvMsgCounter = 0; // Reset counter for the new chain

    // --- Update Our Ratchet Key Pair (for next send) ---
    // This DH step also triggers an update on our *sending* side
    nextState.prevSendMsgCounter = nextState.sendMsgCounter; // Store count of messages sent in the chain we just finished
    nextState.sendMsgCounter = 0; // Reset send counter
    nextState.sendingChain = null; // Discard old sending chain (will be recreated on next send)

    // Generate the *next* ratchet key pair (RK_our, t+1)
    const nextRatchetKeyPair = generateECDHKeyPair();
    console.log("Generated next ratchet key pair (for sending).");

    // --- Triple Ratchet Enhancement (Receiver Side) ---
    // Calculate the *next* enhanced private key (y'_{t+1})
    // Uses the *newly generated* private key (y_{t+1}) and the *just calculated* DH output (I_t)
    const nextEnhancedPrivateKey = calculateEnhancedPrivateKey(
      nextRatchetKeyPair.privateKey, // y_{t+1}
      dhOutput // I_t
    );
    console.log("Calculated next enhanced private key (for sending).");

    // Update state with the new key pair and enhanced key for the *next* DH step initiated by us
    nextState.ourRatchetKeyPair = nextRatchetKeyPair; // Store RK_our, t+1
    nextState.ourEnhancedPrivateKey = nextEnhancedPrivateKey; // Store y'_{t+1}
    console.log("DH ratchet step completed.");
  } // End DH Ratchet Step

  // --- Symmetric Ratchet Decryption ---
  if (!receivingChain) {
    // Should be impossible if DH step logic is correct
    throw new Error(
      "Internal error: Receiving chain not available for decryption after DH check."
    );
  }

  console.log(
    `Attempting symmetric decryption for message N=${header.messageCounter} using current receiving chain.`
  );
  try {
    // Get the message keys for the counter N from the current receiving chain
    // This will advance the chain state, storing skipped keys if N > current index
    const { messageKeys, nextChainState: updatedReceivingChain } =
      await getSymRatchetMessageKey(receivingChain, header.messageCounter);
    nextState.receivingChain = updatedReceivingChain; // Update receiving chain state

    // --- AES Decryption ---
    const adObject = {
      pk: bytesToHex(header.publicKey),
      pn: header.previousCounter,
      n: header.messageCounter,
    };
    const aadBuffer = stringToBytes(JSON.stringify(adObject)); // Reconstruct AD

    console.log("Decrypting ciphertext with AES-GCM.");
    const rawDecKey = new Uint8Array(await exportRawKey(messageKeys.encKey));
    console.debug("🔓 [Decrypt] encKey:", bytesToHex(rawDecKey));
    console.debug(
      "🔓 [Decrypt] iv:",
      bytesToHex(new Uint8Array(messageKeys.iv))
    );
    console.debug("🔓 [Decrypt] aad:", new TextDecoder().decode(aadBuffer));

    plaintext = await decryptAES(
      messageKeys.encKey,
      message.ciphertext,
      messageKeys.iv,
      aadBuffer
    );
    console.log("Symmetric decryption successful.");
  } catch (error) {
    console.error("Symmetric decryption failed:", error);
    // If getSymRatchetMessageKey failed (e.g., counter too old, too far ahead) or AES decrypt failed
    throw new Error(
      `Failed to decrypt message N=${header.messageCounter}: ${error}`
    );
  }

  if (plaintext === null) {
    // Should not happen if decryptAES resolves successfully
    throw new Error("Decryption succeeded but plaintext is null.");
  }

  return { plaintext, nextState };
}

// --- Identity and Key Management ---
// Using LocalStorage for persistence in the browser

const LS_IDENTITY_PREFIX = "identityState";
const LS_SIGNED_PREKEY_PREFIX = "signedPreKey";
const LS_ONETIME_PREKEY_PREFIX = "oneTimePreKey";

interface StorableKeyPair {
  publicKeyHex: string;
  privateKeyHex: string;
}

/**
 * Serializes an ECKeyPair (with Uint8Array keys) into a hex-based object for storage.
 */
function serializeKeyPair(keyPair: ECKeyPair): StorableKeyPair {
  return {
    publicKeyHex: bytesToHex(keyPair.publicKey),
    privateKeyHex: bytesToHex(keyPair.privateKey),
  };
}

/**
 * Deserializes a hex-based object back into an ECKeyPair (with Uint8Array keys).
 */
function deserializeKeyPair(storable: StorableKeyPair): ECKeyPair {
  if (
    !storable ||
    typeof storable.publicKeyHex !== "string" ||
    typeof storable.privateKeyHex !== "string"
  ) {
    throw new Error("Invalid storable key pair format");
  }
  // Use imported hexToBytes
  return {
    publicKey: hexToBytes(storable.publicKeyHex),
    privateKey: hexToBytes(storable.privateKeyHex),
  };
}

// --- Persistence Functions (Example using LocalStorage) ---

/**
 * Saves a signed pre-key pair to localStorage.
 * @param userId User ID associated with the key.
 * @param keyId The ID of the signed pre-key.
 * @param keyPair The key pair to save.
 */
export function saveSignedPreKey(
  userId: number,
  keyId: number,
  keyPair: ECKeyPair
): void {
  try {
    const storageKey = `${LS_SIGNED_PREKEY_PREFIX}:${userId}:${keyId}`;
    const storable = serializeKeyPair(keyPair);
    localStorage.setItem(storageKey, JSON.stringify(storable));
    console.log(
      `[LocalStorage] Saved Signed PreKey ID: ${keyId} for User ID: ${userId}`
    );
  } catch (e) {
    console.error(
      `[LocalStorage] Failed to save Signed PreKey ID: ${keyId}`,
      e
    );
    // Handle potential storage errors (e.g., quota exceeded)
  }
}

/**
 * Saves a one-time pre-key pair to localStorage.
 * @param userId User ID associated with the key.
 * @param keyId The ID of the one-time pre-key.
 * @param keyPair The key pair to save.
 */
export function saveOneTimePreKey(
  userId: number,
  keyId: number,
  keyPair: ECKeyPair
): void {
  try {
    const storageKey = `${LS_ONETIME_PREKEY_PREFIX}:${userId}:${keyId}`;
    const storable = serializeKeyPair(keyPair);
    localStorage.setItem(storageKey, JSON.stringify(storable));
    console.log(
      `[LocalStorage] Saved One-Time PreKey ID: ${keyId} for User ID: ${userId}`
    );
  } catch (e) {
    console.error(
      `[LocalStorage] Failed to save One-Time PreKey ID: ${keyId}`,
      e
    );
  }
}

/**
 * Retrieves a signed pre-key pair from localStorage.
 * Does NOT remove the key.
 * @param identityState - The state of the identity requesting the key (used to get userId).
 * @param keyId - The ID of the signed pre-key to retrieve.
 * @returns A Promise resolving to the ECKeyPair or null if not found/error.
 */
export async function getSignedPreKeyPair(
  identityState: IdentityState, // Assuming IdentityState has an 'id' field
  keyId: number
): Promise<ECKeyPair | null> {
  // This function doesn't need to be async unless storage itself is async
  const userId = identityState.id;
  const storageKey = `${LS_SIGNED_PREKEY_PREFIX}:${userId}:${keyId}`;
  console.log(
    `[LocalStorage] Attempting to get Signed PreKey ID: ${keyId} for User ID: ${userId}`
  );

  try {
    const storedItem = localStorage.getItem(storageKey);
    if (!storedItem) {
      console.warn(`[LocalStorage] Signed PreKey ID: ${keyId} not found.`);
      return null;
    }

    const storable: StorableKeyPair = JSON.parse(storedItem);
    const keyPair = deserializeKeyPair(storable); // Uses imported deserialize
    console.log(`[LocalStorage] Found Signed PreKey ID: ${keyId}.`);
    return keyPair;
  } catch (error) {
    console.error(
      `[LocalStorage] Error retrieving Signed PreKey ID: ${keyId}`,
      error
    );
    return null;
  }
}

/**
 * Retrieves AND REMOVES a one-time pre-key pair from localStorage.
 * Simulates one-time use.
 * @param identityState - The state of the identity requesting the key (used to get userId).
 * @param keyId - The ID of the one-time pre-key to retrieve and remove.
 * @returns A Promise resolving to the ECKeyPair or null if not found/error.
 */
export async function getOneTimePreKeyPair(
  identityState: IdentityState, // Assuming IdentityState has an 'id' field
  keyId: number
): Promise<ECKeyPair | null> {
  // This function doesn't need to be async unless storage itself is async
  const userId = identityState.id;
  const storageKey = `${LS_ONETIME_PREKEY_PREFIX}:${userId}:${keyId}`;
  console.log(
    `[LocalStorage] Attempting to get OT PreKey ID: ${keyId} for User ID: ${userId}`
  );

  try {
    const storedItem = localStorage.getItem(storageKey);
    if (!storedItem) {
      console.warn(`[LocalStorage] OT PreKey ID: ${keyId} not found.`);
      return null;
    }

    // Key found, now remove it *before* returning to simulate one-time use reliably
    localStorage.removeItem(storageKey);
    console.log(`[LocalStorage] Found and REMOVED OT PreKey ID: ${keyId}.`);

    // Parse and deserialize the retrieved item
    const storable: StorableKeyPair = JSON.parse(storedItem);
    const keyPair = deserializeKeyPair(storable); // Uses imported deserialize
    return keyPair;
  } catch (error) {
    console.error(
      `[LocalStorage] Error retrieving/removing OT PreKey ID: ${keyId}`,
      error
    );
    // If there was an error *after* removal, the key is lost.
    // Depending on requirements, you might try to re-save it or handle differently.
    return null;
  }
}

/**
 * Creates a PreKeyBundle for a given identity state.
 * This would typically be done on the server after a user registers keys,
 * but is simulated here for the test.
 * @param identityState The identity state to create a bundle for.
 * @param signedPreKeyId The ID of the signed pre-key to include.
 * @param preKeyId The ID of the one-time pre-key to include.
 * @returns A Promise resolving to the generated PreKeyBundle.
 */
export async function createPreKeyBundle(
  identityState: IdentityState,
  signedPreKeyId: number,
  preKeyId: number
): Promise<PreKeyBundle> {
  console.log(
    `Creating PreKeyBundle for User ID: ${identityState.id} using SPK ID: ${signedPreKeyId}, OPK ID: ${preKeyId}`
  );
  // Get the public key of the signed pre-key from the identity state
  const signedPreKeyPair = identityState.signedPreKeys.get(signedPreKeyId);
  if (!signedPreKeyPair) {
    throw new Error(`Signed pre-key with ID ${signedPreKeyId} not found`);
  }
  const signedPreKey = signedPreKeyPair.publicKey;

  // Get the public key of the one-time pre-key from the identity state
  // Note: In a real scenario, the server would fetch this *without* removing it.
  // The removal happens when the *recipient* uses it during X3DH (`getOneTimePreKeyPair`).
  // For bundle creation, we just need the public part.
  const preKeyPair = identityState.preKeys.get(preKeyId);
  let preKey: ECDHPublicKey; // Declare preKey variable

  if (!preKeyPair) {
    // If it was already used/removed by a previous bundle request simulation, this could happen.
    // A real server manages pre-key availability.
    // Let's try fetching from localStorage directly for bundle creation simulation.
    const storedPreKey = await getPreKeyFromStorageWithoutRemoving(
      identityState.id,
      preKeyId
    );
    if (!storedPreKey) {
      throw new Error(
        `Pre-key with ID ${preKeyId} not found in state or storage.`
      );
    }
    console.warn(
      `PreKey ${preKeyId} not in memory state, fetched from storage for bundle.`
    );
    // We only need the public key for the bundle
    preKey = storedPreKey.publicKey; // Assign to preKey
  } else {
    preKey = preKeyPair.publicKey; // Assign to preKey
  }

  // Get the signature for the signed pre-key
  const signedPreKeySignature =
    identityState.signedPreKeySignatures.get(signedPreKeyId);
  if (!signedPreKeySignature) {
    throw new Error(`Signature for signed pre-key ${signedPreKeyId} not found`);
  }

  // Create the PreKeyBundle
  const bundle: PreKeyBundle = {
    identityId: identityState.id,
    identityKey: identityState.dhKeyPair.publicKey, // IK pub
    signedPreKeyId: signedPreKeyId,
    signedPreKey: signedPreKey, // SPK pub
    signedPreKeySignature: signedPreKeySignature, // Signature(SPK pub)
    preKeyId: preKeyId,
    preKey: preKey, // OPK pub
    signingKey: identityState.signingKeyPair.publicKey, // Public signing key of the bundle owner
  };
  console.log("PreKeyBundle created successfully.");
  return bundle;
}

/** Helper to get pre-key public part from storage without removing it (for bundle creation simulation) */
async function getPreKeyFromStorageWithoutRemoving(
  userId: number,
  keyId: number
): Promise<ECKeyPair | null> {
  const storageKey = `${LS_ONETIME_PREKEY_PREFIX}:${userId}:${keyId}`;
  try {
    const storedItem = localStorage.getItem(storageKey);
    if (!storedItem) return null;
    const storable: StorableKeyPair = JSON.parse(storedItem);
    return deserializeKeyPair(storable);
  } catch (error) {
    console.error(`Error fetching pre-key ${keyId} from storage:`, error);
    return null;
  }
}

/**
 * Creates and initializes a new identity state with pre-keys.
 * Generates keys, signs the signed pre-key, and saves keys to localStorage.
 * @param userId The user ID for the identity.
 * @param numPreKeys The number of one-time pre-keys to generate.
 * @returns A Promise resolving to the initialized IdentityState.
 */
export async function createIdentityState(
  userId: number,
  numPreKeys: number = 10
): Promise<IdentityState> {
  console.log(`Creating new IdentityState for User ID: ${userId}`);
  // Generate identity key pairs (long-term)
  const dhKeyPair = generateECDHKeyPair(); // Identity Key Pair (IK)
  // Use the imported generateSigningKeyPair function
  const signingKeyPair = generateSigningKeyPair(); // Signing Key Pair (SK)
  console.log("Generated identity and signing key pairs.");

  // Initialize maps for pre-keys in memory
  const preKeys = new Map<number, ECKeyPair>(); // One-Time PreKeys (OPK)
  const signedPreKeys = new Map<number, ECKeyPair>(); // Signed PreKey (SPK)
  const signedPreKeySignatures = new Map<number, Uint8Array>(); // Signature(SPK pub)

  // Generate signed pre-key (typically just one active one)
  const signedPreKeyId = 0; // Example ID
  const signedPreKeyPair = generateECDHKeyPair();
  signedPreKeys.set(signedPreKeyId, signedPreKeyPair);
  console.log(`Generated Signed PreKey ID: ${signedPreKeyId}`);

  // Sign the public part of the signed pre-key with the long-term signing key
  const signedPreKeySignature = await signData(
    signingKeyPair.privateKey, // Use the signing private key
    signedPreKeyPair.publicKey // Sign the public key bytes
  );
  signedPreKeySignatures.set(signedPreKeyId, signedPreKeySignature);
  console.log("Signed the Signed PreKey.");

  // Save signed pre-key to localStorage for persistence
  saveSignedPreKey(userId, signedPreKeyId, signedPreKeyPair);

  // Generate one-time pre-keys
  console.log(`Generating ${numPreKeys} One-Time PreKeys...`);
  for (let i = 0; i < numPreKeys; i++) {
    const preKeyPair = generateECDHKeyPair();
    preKeys.set(i, preKeyPair); // Store in memory map

    // Save to localStorage for persistence
    saveOneTimePreKey(userId, i, preKeyPair);
  }
  console.log("Generated and saved One-Time PreKeys.");

  // Create the identity state object
  const identityState: IdentityState = {
    id: userId,
    dhKeyPair, // IK
    signingKeyPair, // SK
    preKeys, // OPKs (in memory copy)
    signedPreKeys, // SPK (in memory copy)
    signedPreKeySignatures, // Signature (in memory copy)
  };

  console.log(`IdentityState created for User ID: ${userId}`);
  return identityState;
}

```

```test\triple-ratchet-test.ts
// === File: src/test/triple-ratchet-test.ts ===

import {
  createIdentityState,
  createPreKeyBundle,
  initializeRatchetInitiator,
  initializeRatchetReceiver,
  ratchetEncrypt,
  ratchetDecrypt,
} from "../protocol/ratchet-logic";
import { bytesToString, stringToBytes } from "../utils/buffer";
import type { IdentityState, RatchetState, PreKeyBundle } from "../types";

/**
 * A class to test the Triple Ratchet protocol implementation end-to-end.
 * This demonstrates the full flow of secure communication using the protocol.
 */
export class TripleRatchetTest {
  private aliceIdentity!: IdentityState;
  private bobIdentity!: IdentityState;
  private aliceState!: RatchetState;
  private bobState!: RatchetState;
  private bobPreKeyBundle!: PreKeyBundle;
  private messagesFromAlice: string[] = [];
  private messageFromBob: string[] = [];

  /**
   * Initialize test identities and states for both parties.
   */
  public async setup(): Promise<void> {
    console.log("=== Setting up Triple Ratchet Test ===");

    try {
      // Step 1: Create identities for Alice and Bob
      console.log("Creating identities for Alice and Bob...");
      this.aliceIdentity = await createIdentityState(1); // Alice is user 1
      this.bobIdentity = await createIdentityState(2); // Bob is user 2

      // Step 2: Create Bob's PreKeyBundle (that would normally be published on a server)
      console.log("Creating Bob's PreKeyBundle...");
      this.bobPreKeyBundle = await createPreKeyBundle(this.bobIdentity, 0, 0);

      // Step 3: Alice initializes a session with Bob using his bundle
      console.log("Alice initializing session with Bob...");
      this.aliceState = await initializeRatchetInitiator(
        this.aliceIdentity,
        this.bobPreKeyBundle
      );

      console.log("Setup complete!");
    } catch (error) {
      console.error("Error during setup:", error);
      throw error;
    }
  }

  /**
   * Alice sends a first message to Bob, which establishes the session on Bob's side
   * @param message The message text to send
   */
  public async aliceSendsFirstMessage(message: string): Promise<void> {
    console.log("\n=== Alice Sends First Message ===");

    try {
      // Step 1: Alice encrypts her first message (this will be a PreKey message)
      console.log(`Alice encrypting: "${message}"`);
      const plaintext = stringToBytes(message);
      const { message: encryptedMessage, nextState } = await ratchetEncrypt(
        this.aliceState,
        plaintext
      );

      // Update Alice's state
      this.aliceState = nextState;

      // Step 2: Bob receives the PreKey message and initializes his session
      console.log("Bob receiving and initializing his session...");
      this.bobState = await initializeRatchetReceiver(
        this.bobIdentity,
        encryptedMessage
      );

      // Step 3: Bob decrypts the message
      console.log("Bob decrypting the message...");
      const { plaintext: decryptedPlaintext, nextState: bobNextState } =
        await ratchetDecrypt(this.bobState, encryptedMessage);

      // Update Bob's state
      this.bobState = bobNextState;

      // Step 4: Convert the decrypted message to a string
      const decryptedMessage = bytesToString(decryptedPlaintext);
      console.log(`Bob decrypted: "${decryptedMessage}"`);

      // Store for verification
      this.messagesFromAlice.push(message);

      if (message === decryptedMessage) {
        console.log("First message successfully sent and received!");
      } else {
        console.error("Decryption failed: messages don't match!");
      }
    } catch (error) {
      console.error("Error in aliceSendsFirstMessage:", error);
      throw error;
    }
  }

  /**
   * Alice sends subsequent messages to Bob (after the session is established)
   * @param message The message text to send
   */
  public async aliceSendsMessage(message: string): Promise<void> {
    console.log("\n=== Alice Sends Message ===");

    try {
      // Step 1: Alice encrypts her message
      console.log(`Alice encrypting: "${message}"`);
      const plaintext = stringToBytes(message);
      const { message: encryptedMessage, nextState } = await ratchetEncrypt(
        this.aliceState,
        plaintext
      );

      // Update Alice's state
      this.aliceState = nextState;

      // Step 2: Bob decrypts the message
      console.log("Bob decrypting the message...");
      const { plaintext: decryptedPlaintext, nextState: bobNextState } =
        await ratchetDecrypt(this.bobState, encryptedMessage);

      // Update Bob's state
      this.bobState = bobNextState;

      // Step 3: Convert the decrypted message to a string
      const decryptedMessage = bytesToString(decryptedPlaintext);
      console.log(`Bob decrypted: "${decryptedMessage}"`);

      // Store for verification
      this.messagesFromAlice.push(message);

      if (message === decryptedMessage) {
        console.log("Message successfully sent and received!");
      } else {
        console.error("Decryption failed: messages don't match!");
      }
    } catch (error) {
      console.error("Error in aliceSendsMessage:", error);
      throw error;
    }
  }

  /**
   * Bob sends a message to Alice
   * @param message The message text to send
   */
  public async bobSendsMessage(message: string): Promise<void> {
    console.log("\n=== Bob Sends Message ===");

    try {
      // Step 1: Bob encrypts his message
      console.log(`Bob encrypting: "${message}"`);
      const plaintext = stringToBytes(message);
      const { message: encryptedMessage, nextState } = await ratchetEncrypt(
        this.bobState,
        plaintext
      );

      // Update Bob's state
      this.bobState = nextState;

      // Step 2: Alice decrypts the message
      console.log("Alice decrypting the message...");
      const { plaintext: decryptedPlaintext, nextState: aliceNextState } =
        await ratchetDecrypt(this.aliceState, encryptedMessage);

      // Update Alice's state
      this.aliceState = aliceNextState;

      // Step 3: Convert the decrypted message to a string
      const decryptedMessage = bytesToString(decryptedPlaintext);
      console.log(`Alice decrypted: "${decryptedMessage}"`);

      // Store for verification
      this.messageFromBob.push(message);

      if (message === decryptedMessage) {
        console.log("Message successfully sent and received!");
      } else {
        console.error("Decryption failed: messages don't match!");
      }
    } catch (error) {
      console.error("Error in bobSendsMessage:", error);
      throw error;
    }
  }

  /**
   * Demonstrates key rotation by sending multiple messages back and forth
   * This shows the forward secrecy and break-in recovery properties
   */
  public async demonstrateKeyRotation(messageCount: number = 5): Promise<void> {
    console.log("\n=== Demonstrating Key Rotation ===");
    console.log(
      `Sending ${messageCount} messages in each direction to trigger ratchet turns...`
    );

    try {
      // Alice and Bob alternate sending messages
      for (let i = 0; i < messageCount; i++) {
        // Alice sends message to Bob
        const aliceMessage = `Alice's message #${i + 1}: Hello Bob!`;
        await this.aliceSendsMessage(aliceMessage);

        // Bob sends message to Alice
        const bobMessage = `Bob's message #${i + 1}: Hello Alice!`;
        await this.bobSendsMessage(bobMessage);

        console.log(`Completed round ${i + 1} of message exchange`);

        // Log some state information to show changes
        console.log(`Alice's send counter: ${this.aliceState.sendMsgCounter}`);
        console.log(`Bob's send counter: ${this.bobState.sendMsgCounter}`);
      }

      console.log("\nKey rotation demonstration complete!");
      console.log(
        "The Triple Ratchet protocol has successfully maintained secure communication"
      );
      console.log(
        "with automatic key rotation for forward secrecy and break-in recovery."
      );
    } catch (error) {
      console.error("Error in demonstrateKeyRotation:", error);
      throw error;
    }
  }

  /**
   * Demonstrates the out-of-order message handling capability
   */
  public async demonstrateOutOfOrderMessages(): Promise<void> {
    console.log("\n=== Demonstrating Out-of-Order Message Handling ===");

    try {
      // Alice encrypts three messages in sequence
      console.log("Alice encrypting three messages in sequence...");
      const message1 = "Message 1: This should arrive first";
      const message2 = "Message 2: This should arrive second";
      const message3 = "Message 3: This should arrive third";

      // Encrypt all three messages
      const plaintext1 = stringToBytes(message1);
      const { message: encryptedMessage1, nextState: aliceState1 } =
        await ratchetEncrypt(this.aliceState, plaintext1);

      // Update Alice's state for the next message
      const aliceStateAfterMsg1 = aliceState1;

      const plaintext2 = stringToBytes(message2);
      const { message: encryptedMessage2, nextState: aliceState2 } =
        await ratchetEncrypt(aliceStateAfterMsg1, plaintext2);

      // Update Alice's state for the next message
      const aliceStateAfterMsg2 = aliceState2;

      const plaintext3 = stringToBytes(message3);
      const { message: encryptedMessage3, nextState: aliceState3 } =
        await ratchetEncrypt(aliceStateAfterMsg2, plaintext3);

      // Update Alice's final state
      this.aliceState = aliceState3;

      // Bob receives the messages out of order: 3, 1, 2
      console.log(
        "Bob receiving and decrypting messages out of order: 3, 1, 2"
      );

      // Message 3 (received first)
      console.log("Bob decrypting message 3 (received first)...");
      const { plaintext: decryptedPlaintext3, nextState: bobStateAfterMsg3 } =
        await ratchetDecrypt(this.bobState, encryptedMessage3);

      // Update Bob's state
      const bobStateAfterReceivingMsg3 = bobStateAfterMsg3;

      // Message 1 (received second)
      console.log("Bob decrypting message 1 (received second)...");
      const { plaintext: decryptedPlaintext1, nextState: bobStateAfterMsg1 } =
        await ratchetDecrypt(bobStateAfterReceivingMsg3, encryptedMessage1);

      // Update Bob's state
      const bobStateAfterReceivingMsg1 = bobStateAfterMsg1;

      // Message 2 (received last)
      console.log("Bob decrypting message 2 (received last)...");
      const { plaintext: decryptedPlaintext2, nextState: bobStateAfterMsg2 } =
        await ratchetDecrypt(bobStateAfterReceivingMsg1, encryptedMessage2);

      // Update Bob's final state
      this.bobState = bobStateAfterMsg2;

      // Check if all messages were decrypted correctly
      const decryptedMessage1 = bytesToString(decryptedPlaintext1);
      const decryptedMessage2 = bytesToString(decryptedPlaintext2);
      const decryptedMessage3 = bytesToString(decryptedPlaintext3);

      console.log("\nDecrypted messages:");
      console.log(`Message 1: "${decryptedMessage1}"`);
      console.log(`Message 2: "${decryptedMessage2}"`);
      console.log(`Message 3: "${decryptedMessage3}"`);

      if (
        message1 === decryptedMessage1 &&
        message2 === decryptedMessage2 &&
        message3 === decryptedMessage3
      ) {
        console.log(
          "\nAll messages successfully decrypted in the correct order!"
        );
        console.log(
          "The Triple Ratchet protocol successfully handled out-of-order messages."
        );
      } else {
        console.error("\nDecryption failed: some messages don't match!");
      }
    } catch (error) {
      console.error("Error in demonstrateOutOfOrderMessages:", error);
      throw error;
    }
  }

  /**
   * Run the complete test suite
   */
  public async runTest(): Promise<void> {
    console.log("========================================");
    console.log("      TRIPLE RATCHET TEST SUITE        ");
    console.log("========================================");

    try {
      // Initialize test environment
      await this.setup();

      // Test the initial message exchange
      await this.aliceSendsFirstMessage(
        "Hello Bob! This is the first message."
      );

      // Test regular message exchange
      await this.bobSendsMessage("Hi Alice! I received your message.");
      await this.aliceSendsMessage("Great! Let's test our secure channel.");

      // Test key rotation
      await this.demonstrateKeyRotation(3);

      // Test out-of-order message handling
      await this.demonstrateOutOfOrderMessages();

      console.log("\n========================================");
      console.log("      TEST SUITE COMPLETED SUCCESSFULLY  ");
      console.log("========================================");
    } catch (error) {
      console.error("\n========================================");
      console.error("      TEST SUITE FAILED                ");
      console.error("========================================");
      console.error("Error:", error);
    }
  }
}

/**
 * Run the test when this file is executed directly
 */
(async function () {
  const test = new TripleRatchetTest();
  await test.runTest();
})();

```

```types\index.ts
// === File: src/types/index.ts ===

// Cryptographic key types using noble-curves format (Uint8Array) and Web Crypto
export type ECDHPublicKey = Uint8Array; // Uncompressed or Compressed Point Bytes
export type ECDHPrivateKey = Uint8Array; // 32-byte scalar
export type ECDSAPublicKey = Uint8Array; // Uncompressed or Compressed Point Bytes
export type ECDSAPrivateKey = Uint8Array; // 32-byte scalar
export type HMACKey = CryptoKey; // Web Crypto API Key Object
export type AESKey = CryptoKey; // Web Crypto API Key Object

// Key pair types
export interface ECKeyPair {
  publicKey: ECDHPublicKey;
  privateKey: ECDHPrivateKey;
}

export interface SigningKeyPair {
  publicKey: ECDSAPublicKey;
  privateKey: ECDSAPrivateKey;
}

// Serialized EC public key format (Using Hex for simplicity)
export type SerializedECPublicKey = string; // Hex representation of public key bytes

// Message types for the Triple Ratchet protocol
export enum MessageType {
  NORMAL = 0,
  PRE_KEY = 1,
}

// A message header contains metadata for a ratchet message
export interface MessageHeader {
  publicKey: ECDHPublicKey; // Sender's ratchet public key (bytes)
  previousCounter: number; // Number of messages in previous sending chain
  messageCounter: number; // Message number in current chain
}

// A ratchet message contains the encrypted data and metadata
export interface RatchetMessage {
  type: MessageType;
  header: MessageHeader;
  ciphertext: ArrayBuffer;
  // For PreKeyMessages only
  identityKey?: ECDHPublicKey; // Sender's long-term identity key (bytes)
  preKeyId?: number;
  signedPreKeyId?: number;
}

// The message keys used for encryption/decryption
export interface MessageKeys {
  encKey: AESKey; // Web Crypto AES Key
  authKey: HMACKey; // Web Crypto HMAC Key
  iv: ArrayBuffer;
}

// A PreKeyBundle is used to establish initial communication
export interface PreKeyBundle {
  identityId: number;
  identityKey: ECDHPublicKey; // bytes
  signedPreKeyId: number;
  signedPreKey: ECDHPublicKey; // bytes
  signedPreKeySignature: Uint8Array; // Signature bytes
  preKeyId: number;
  preKey: ECDHPublicKey; // bytes
  signingKey: ECDSAPublicKey; // Public signing key of the bundle owner (bytes)
}

// --- State Types for Functional Approach ---

/**
 * State for a symmetric key ratchet chain (sending or receiving)
 */
export interface RatchetChainState {
  chainKey: HMACKey; // Web Crypto Key
  chainIndex: number;
  skippedMessageKeys: Map<number, MessageKeys>; // Stores keys for out-of-order messages
}

/**
 * Represents the complete state of a Triple Ratchet session for one party
 */
export interface RatchetState {
  // Own identity info (simplified for this example)
  identityPrivateKey: ECDHPrivateKey; // bytes
  identityPublicKey: ECDHPublicKey; // bytes

  // Remote party's identity info
  remoteIdentityKey: ECDHPublicKey; // bytes
  remoteSigningKey: ECDSAPublicKey; // bytes

  // Core Ratchet State
  rootKey: HMACKey; // Web Crypto Key
  ourRatchetKeyPair: ECKeyPair; // Our current ephemeral DH key pair (bytes)
  theirRatchetKey: ECDHPublicKey | null; // Their current ephemeral DH public key (bytes)

  // Triple Ratchet Enhancement
  // This now holds the actual enhanced private key scalar bytes x_t' = x_t * H(I_t) mod q
  ourEnhancedPrivateKey: ECDHPrivateKey; // bytes

  // Symmetric Key Ratchet Chains
  sendingChain: RatchetChainState | null;
  receivingChain: RatchetChainState | null;

  // Counters
  sendMsgCounter: number; // Messages sent in the current sending chain
  recvMsgCounter: number; // Messages received in the current receiving chain (Note: might not be needed if using chainIndex)
  prevSendMsgCounter: number; // Number of messages sent in the *previous* sending chain

  // Storage for message keys skipped during DH ratchet steps
  // Key: Hex(remote public key) + message counter
  skippedRatchetKeys: Map<string, MessageKeys>;
}

/**
 * Represents the state of a user's identity keys (simplified)
 */
export interface IdentityState {
  id: number;
  signingKeyPair: SigningKeyPair; // bytes
  dhKeyPair: ECKeyPair; // bytes
  // Add maps for preKeys (ECKeyPair), signedPreKeys (ECKeyPair), signatures (Map<number, Uint8Array>) etc.
  preKeys: Map<number, ECKeyPair>;
  signedPreKeys: Map<number, ECKeyPair>;
  signedPreKeySignatures: Map<number, Uint8Array>;
}

```

```utils\buffer.ts
// === File: src/utils/buffer.ts ===

import {
  bytesToHex as nobleBytesToHex,
  hexToBytes as nobleHexToBytes,
} from "@noble/hashes/utils";

/**
 * Concatenates multiple ArrayBuffers or Uint8Arrays.
 * @param buffers ArrayBuffers or Uint8Arrays to concatenate.
 * @returns A new Uint8Array containing the concatenated data.
 */
export function concatBuffers(
  ...buffers: (ArrayBuffer | Uint8Array)[]
): Uint8Array {
  const totalLength = buffers.reduce((sum, buf) => sum + buf.byteLength, 0);
  const result = new Uint8Array(totalLength);
  let offset = 0;

  for (const buffer of buffers) {
    result.set(new Uint8Array(buffer), offset);
    offset += buffer.byteLength;
  }

  return result;
}

/**
 * Compares two ArrayBuffers or Uint8Arrays for equality.
 * Uses constant time comparison if possible.
 * @param a The first buffer.
 * @param b The second buffer.
 * @returns True if the buffers are identical, false otherwise.
 */
export function equalBuffers(
  a: ArrayBuffer | Uint8Array,
  b: ArrayBuffer | Uint8Array
): boolean {
  const viewA = new Uint8Array(a);
  const viewB = new Uint8Array(b);

  if (viewA.length !== viewB.length) {
    return false;
  }

  // Constant time comparison
  let diff = 0;
  for (let i = 0; i < viewA.length; i++) {
    diff |= viewA[i] ^ viewB[i];
  }
  return diff === 0;
}

// Use noble-hashes utilities for hex conversion and re-export
export const bytesToHex = nobleBytesToHex;
export const hexToBytes = nobleHexToBytes;

/**
 * Converts a UTF-8 string to an Uint8Array.
 * @param str The string to encode.
 * @returns The Uint8Array representation.
 */
export function stringToBytes(str: string): Uint8Array {
  return new TextEncoder().encode(str);
}

/**
 * Converts an ArrayBuffer or Uint8Array to a UTF-8 string.
 * @param buffer The buffer to decode.
 * @returns The decoded string.
 */
export function bytesToString(buffer: ArrayBuffer | Uint8Array): string {
  return new TextDecoder().decode(buffer);
}

```

```utils\environment.ts
// === File: src/utils/environment.ts ===

/**
 * Environment detection utilities
 */
export const isBrowser =
  typeof window !== "undefined" && typeof window.crypto !== "undefined";

/**
 * Gets the crypto implementation from the environment (for Web Crypto parts).
 * @throws Error if Web Crypto API is not available.
 * @returns The Crypto object.
 */
export function getCrypto(): Crypto {
  if (isBrowser) {
    return window.crypto;
  }
  throw new Error("Web Crypto API is not available in this environment");
}

```